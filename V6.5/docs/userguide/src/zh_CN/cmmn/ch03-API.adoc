[[chapterApi]]

== The Flowable CMMN API
== Flowable CMMN API

[[apiEngine]]


=== The Process CMMN Engine API and services
=== 流程 CMMN 引擎 API 与服务类

The engine API is the most common way of interacting with Flowable. The main starting point is the +CmmnEngine+, which can be created in several ways as described in the  <<configuration,configuration section>>. From the CmmnEngine, you can obtain the various services that contain the case/CMMN methods. CmmnEngine and the services objects are thread safe, so you can keep a reference to one of those for a whole server.
引擎 API 是与 Flowable 交互的最常用方式。核心起点是可以通过<<configuration,配置部分>>中描述的几种方式创建的 ++CMMN 引擎++。从 CMMN 引擎中，您可以获得包含案例/CMMN 方法的各种服务类。CMMN 引擎和其服务类对象是线程安全的，因此您可以为整个服务保留其中一个引用。

[source,java,linenums]
----
CmmnEngine cmmnEngine = CmmnEngineConfiguration.createStandaloneCmmnEngineConfiguration();

CmmnRuntimeService runtimeService = cmmnEngine.getCmmnRuntimeService();
CmmnRepositoryService repositoryService = cmmnEngine.getCmmnRepositoryService();
CmmnTaskService taskService = cmmnEngine.getCmmnTaskService();
CmmnManagementService managementService = cmmnEngine.getCmmnManagementService();
CmmnHistoryService historyService = cmmnEngine.getCmmnHistoryService();
----

+CmmnEngineConfiguration.createStandaloneCmmnEngineConfiguration()+ will initialize and build a CMMN engine and afterwards always return the CMMN engine.
+CmmnEngineConfiguration.createStandaloneCmmnEngineConfiguration()+ 将初始化并构建 CMMN 引擎，然后始终返回这个 CMMN 引擎。


The CmmnEngineConfiguration class will scan for all +flowable.cmmn.cfg.xml+ and +flowable-cmmn-context.xml+ files. For all +flowable.cmmn.cfg.xml+ files, the CMMN engine will be built in the typical Flowable way: +CmmnEngineConfiguration.createCmmnEngineConfigurationFromInputStream(inputStream).buildCmmnEngine()+. For all +flowable-cmmn-context.xml+ files, the CMMN engine will be built in the Spring way: first the Spring application context is created and then the CMMN engine is obtained from that application context.
CmmnEngineConfiguration 类将扫描所有 +flowable.cmmn.cfg.xml+ 和 +flowable-cmmn-context.xml+ 配置文件。对于所有 +flowable.cmmn.cfg.xml+ 配置文件，CMMN 引擎将以典型的 Flowable 方式构建：+CmmnEngineConfiguration.createCmmnEngineConfigurationFromInputStream(inputStream).buildCmmnEngine()+。对于所有 +flowable-cmmn-context.xml+ 配置文件，CMMN 引擎将以 Spring 方式构建：首先创建 Spring 应用程序上下文，然后 CMMN 引擎会从该应用程序上下文中获取。

All services are stateless. This means that you can easily run Flowable on multiple nodes in a cluster, each going to the same database, without having to worry about which machine actually executed previous calls. Any call to any service is idempotent regardless of where it is executed.
所有的服务类均是无状态的。这意味着您可以轻松地在群集中的多个节点上运行Flowable，每个节点都连接同一个数据库，而不必担心哪台机器实际执行了旧的调用。对任何服务类的任何调用都是幂等的，无论它在何处执行。

The *CmmnRepositoryService* is probably the first service needed when working with the Flowable CMMN engine. This service offers operations for managing and manipulating +deployments+ and +case definitions+. Without going into much detail here, a case definition is a Java counterpart of the CMMN 1.1 case. It is a representation of the structure and behavior of each of the steps of a case. A +deployment+ is the unit of packaging within the Flowable CMMN engine. A deployment can contain multiple CMMN 1.1 XML files and any other resource. The choice of what is included in one deployment is up to the developer. It can range from a single process CMMN 1.1 XML file to a whole package of cases and relevant resources (for example, the deployment 'hr-cases' could contain everything related to HR cases). The +CmmnRepositoryService+ can +deploy+ such packages. Deploying a deployment means it is uploaded to the engine, where all cases are inspected and parsed before being stored in the database. From that point on, the deployment is known to the system and any process included in the deployment can now be started.
*CmmnRepositoryService* 可能是 Flowable CMMN 引擎工作时所需的第一个服务类。该服务类提供用于管理和使用++部署文件++和++案例定义++的操作。案例定义是 CMMN 1.1案例的 Java 对应物，它表示案例的每个步骤的结构和行为，这里不再过多介绍。++部署文件++是 Flowable CMMN 引擎中的打包单元。部署文件可以包含多个CMMN 1.1 XML文件和任何其他资源，其中具体包含哪些内容取决于开发人员。它的范围可以从单个流程 CMMN 1.1 XML 文件到整个案例和相关资源的包（例如，部署文件“hr-cases”可能包含与 HR 案例相关的所有内容）。+CmmnRepositoryService+ 可以++发布++这样的包。发布一个部署文件意味着将其上载到引擎，在该引擎中，所有案例在存储到数据库之前都会被检查和解析。从那一刻起，系统会感知到这个部署文件，并且部署文件中包含的任何流程都可以被发起。

Furthermore, this service allows you to:
此外，这个服务类允许您：

* Query on deployments and case definitions known to the engine.
* 查询引擎已知的部署文件和案例定义。
* Retrieve various resources, such as files contained within the deployment or case diagrams that were auto-generated by the engine.
* 检索各种资源，例如部署文件中包含的文件或引擎自动生成的案例图。
* Retrieve a POJO version of the case definition, which can be used to introspect the case using Java rather than XML.
* 检索案例定义的 POJO 版本，它可用于使用 Java 而不是 JSON 进行内省。

While the +CmmnRepositoryService+ is mostly about static information (data that doesn't change, or at least not a lot), the *CmmnRuntimeService* is quite the opposite. It deals with starting new case instances of case definitions. As said above, a +case definition+ defines the structure and behavior of the different steps in a case. A case instance is one execution of such a case definition. For each case definition there typically are many instances running at the same time. The +CmmnRuntimeService+ also is the service which is used to retrieve and store +case variables+. This is data that is specific to the given case instance and can be used by various constructs in the case (for example, a plan transition condition often uses process variables to determine which path is chosen to continue the case). The +CmmnRuntimeservice+ also allows you to query on case instances and plan items. Plan items are a representation of the enabled plan items of CMMN 1.1. Lastly, the +CmmnRuntimeService+ is used whenever a case instance is waiting for an external trigger and the case needs to be continued. A case instance can have various +wait states+ and this service contains various operations to 'signal' to the instance that the external trigger is received and the case instance can be continued.
+CmmnRepositoryService+ 主要与静态信息（数据不会改变，至少不会变很多）有关，而 *CmmnRuntimeService* 恰恰相反，它涉及启动案例定义的新案例实例。如上所述，++案例定义++定义了案例的不同步骤的结构和行为。案例实例是案例定义的一次执行。对于每个案例定义，通常会有许多实例同时运行。CmmnRuntimeService 也是用于检索和存储案例变量的服务类。变量是特定于指定案例实例的数据，并且可以让案例中的各种结构使用（例如，方案的跳转条件通常使用流程变量来确定选择哪个路径来继续流转该案例）。CmmnRuntimeService 还允许您查询案例实例和方案条目。方案条目是 CMMN 1.1的已启用方案条目的表示。最后，无论何时案例实例需要继续流转并等待外部触发时都会使用 CmmnRuntimeService。案例实例可以具有各种等待状态，该服务类包含各种操作来向实例“发信号”并由外部触发器接收，然后案例实例可以继续流转。


Tasks that need to be performed by human users of the system are core to a CMMN engine such as Flowable. Everything around tasks is grouped in the *CmmnTaskService*, such as:
需要由系统的操作用户执行的任务是 Flowable 这类 CMMN 引擎的核心。围绕任务的所有内容都分组在 *CmmnTaskService* 中，例如：

* Querying tasks assigned to users or groups
* 查询分配给用户或组的任务
* Creating new _standalone_ tasks. These are tasks that are not related to a process instances.
* 创建新的__独立__任务，这些任务与流程实例无关。
* Manipulating to which user a task is assigned or which users are in some way involved with the task.
* 操作派遣任务的参与人或以某种方式参与任务的用户。
* Claiming and completing a task. Claiming means that someone decided to be the assignee for the task, meaning that this user will complete the task. Completing means 'doing the work of the tasks'. Typically this is filling in a form of sorts.
* 签收并完成一个任务。 签收意味着某人决定成为该任务的操作人，这意味着该用户将审批该任务，审批意味着“完成任务”。通常这是填写一种表单。

The *CmmnHistoryService* exposes all historical data gathered by the Flowable CMMN engine. When executing cases, a lot of data can be kept by the engine (this is configurable), such as case instance start times, who did which tasks, how long it took to complete the tasks, which path was followed in each case instance, and so on. This service exposes mainly query  capabilities to access this data.
*CmmnHistoryService* 暴露 Flowable CMMN 引擎收集的所有历史数据。在执行案例时，引擎可以保存大量数据（可以通过配置决定是否启用），例如案例实例开始时间，谁执行哪些任务，审批任务花费多长时间，每个案例实例流经哪条路径等。此服务类主要暴露查询功能以访问此类数据。

The *CmmnManagementService* gives access to low-level information about the database tables, allows to query for the different types of jobs and to execute them.
*CmmnManagementService* 提供对数据库表低级信息的访问，允许查询不同类型的工作并执行它们。

For more detailed information on the service operations and the engine API, see link:$$http://www.flowable.org/docs/javadocs/index.html$$[the javadocs].
有关服务操作和引擎 API 的更多详细信息，请参阅link:$$http://www.flowable.org/docs/javadocs/index.html$$[文档]。


=== Exception strategy
=== 例外的策略

The base exception in Flowable is the +org.flowable.engine.common.api.FlowableException+, an unchecked exception. This exception can be thrown at all times by the API, but 'expected' exceptions that happen in specific methods are documented in link:$$http://www.flowable.org/docs/javadocs/index.html$$[ the javadocs]. For example, an extract from ++CmmnTaskService++:
Flowable 中的基础异常是 +org.flowable.engine.FlowableException+，这是一个未经检查的异常。这种异常可以被 API 随时抛出，其他特定方法中发生的“预期中的”异常被记录在link:$$http://www.flowable.org/docs/javadocs/index.html$$[文档]中。例如 ++CmmnTaskService++ 的摘录：

[source,java,linenums]
----
/**
 * Called when the task is successfully executed.
 * 成功执行任务时调用。
 * @param taskId the id of the task to complete, cannot be null.
 * @param taskId 要完成的任务的id，不能为空。
 * @throws FlowableObjectNotFoundException when no task exists with the given id.
 * @throws FlowableObjectNotFoundException 当指定id的任务不存在时抛出。
 */
 void complete(String taskId);
----

In the example above, when an id is passed for which no task exists, an exception will be thrown. Also, since the javadoc *explicitly states that taskId cannot be null, an +FlowableIllegalArgumentException+ will be thrown when +null+ is passed*.
在上面的示例中，当传递不存在的任务 id 时，将抛出异常。同样的，由于 Java 文档**明确声明 taskId 不能为 null，因此在传递 +null+ 时将抛出 +FlowableIllegalArgumentException+** 。

Even though we want to avoid a big exception hierarchy, the following subclasses are thrown in specific cases. All other errors that occur during process-execution or API-invocation that don't fit into the possible exceptions below, are thrown as regular ++FlowableExceptions++s.
尽管我们想要避免一个大的异常层次结构，下列的异常子类仍会在特定情况下被抛出。在流程执行或 API 调用期间发生的所有其他错误都不适合下面可能发生的异常，这些错误将作为常规 ++FlowableExceptions++ 抛出。

* ++FlowableWrongDbException++: Thrown when the Flowable engine discovers a mismatch between the database schema version and the engine version.
* ++FlowableWrongDbException++：当 Flowable 引擎发现数据库 Schema 版本与引擎版本不匹配时抛出。
* ++FlowableOptimisticLockingException++: Thrown when an optimistic locking occurs in the data store caused by concurrent access of the same data entry.
* ++FlowableOptimisticLockingException++：当由同一数据条目的并发访问引起的数据存储中发生乐观锁问题时抛出。
* ++FlowableClassLoadingException++: Thrown when a class requested to load was not found or when an error occurred while loading it (e.g. JavaDelegates, TaskListeners, ...).
* ++FlowableClassLoadingException++：当未找到请求加载的类或加载时发生错误时抛出（例如 Java 代理类、任务监听器等）。
* ++FlowableObjectNotFoundException++: Thrown when an object that is requested or actioned does not exist.
* ++FlowableObjectNotFoundException++：当请求或操作的对象不存在时抛出。
* ++FlowableIllegalArgumentException++: An exception indicating that an illegal argument has been supplied in a Flowable API-call, an illegal value was configured in the engine's configuration or an illegal value has been supplied or an illegal value is used in a process-definition.
* ++FlowableIllegalArgumentException++：这个异常表示在 Flowable API 调用中使用了非法参数、在引擎的配置中配置了非法值。
* ++FlowableTaskAlreadyClaimedException++: Thrown when a task is already claimed, when the +taskService.claim(...)+ is called.
* ++FlowableTaskAlreadyClaimedException++：当一个任务已经被签收时，再次调用 +taskService.claim(...)+ 时抛出。


[[queryAPI]]


=== Query API
=== 查询 API

There are two ways of querying data from the engine: the query API and native queries. The Query API allows you to program completely typesafe queries with a fluent API. You can add various conditions to your queries (all of which are applied together as a logical AND) and precisely one ordering. The following code shows an example:
有两种方法可以从引擎查询数据：使用查询 API 和本地查询。查询 API 允许您使用流畅的 API 编写完全类型安全的查询。您可以为查询添加各种查询条件（所有条件共同应用逻辑与）与一个排序参数。示例如下：

[source,java,linenums]
----
List<Task> tasks = taskService.createTaskQuery()
    .taskAssignee("kermit")
    .orderByDueDate().asc()
    .list();
----

[[apiVariables]]

=== Variables
=== 变量

Every case instance needs and uses data to execute the steps it's made up of. In Flowable, this data is called _variables_, which are stored in the database. Variables can be used in expressions (for example, in the condition of a sentry), in Java service tasks when calling external services (for example to provide the input or store the result of the service call), and so on.
每个案例实例都需要并使用数据来执行自身节点来进行流转。在 Flowable 中, 这种数据被称为__变量__, 它们存储在数据库中。变量可以在表达式中使用（例如在哨兵的条件中）、在调用外部服务时的 Java 服务任务中使用（例如提供输入或存储服务调用的结果）等。

A case instance can have variables (called _case variables_), but also _plan item instances_ and human tasks can have variables. A case instance can have any number of variables. Each variable is stored in a row in the _ACT_RU_VARIABLE_ database table.
案例实例可以包含变量（称为__案例变量__）, 同样的__方案条目实例__和人工任务也可以包含变量。案例实例可以包含任意数量的变量。每个变量都存储在 __ACT_RU_VARIABLE__ 数据库表的一行中。

The _createCaseInstanceBuilder_ method has optional methods to provide the variables when the case instance is created and started through the _CmmnRuntimeService_:
_createCaseInstanceBuilder_方法具有可选方法，用于通过 _CmmnRuntimeService_ 创建案例实例并启动时提供变量：

[source,java,linenums]
----
CaseInstance caseInstance = runtimeService.createCaseInstanceBuilder().variable("var1", "test").start();
----

Variables can be added during case execution. For example, (_CmmnRuntimeService_):
在案例执行期间可以添加变量。例如 _CmmnRuntimeService_：

[source,java,linenums]
----
void setVariables(String caseInstanceId, Map<String, ? extends Object> variables);
----

Variables can also be retrieved, as shown below. Note that similar methods exist on the _CmmnTaskService_.
如下所示，变量同样可以被检索。请注意 _CmmnTaskService_ 上存在类似的方法。

[source,java,linenums]
----
Map<String, Object> getVariables(String caseInstanceId);
Object getVariable(String caseInstanceId, String variableName);
----

Variables are often used in Java service tasks, expressions, scripts, and so on.
变量通常用于 Java 服务任务、达式和脚本中等。

[[apiTransientVariables]]

=== Transient variables
=== 临时变量

Transient variables are variables that behave like regular variables, but are not persisted. Typically, transient variables are used for advanced use cases.  When in doubt, use a regular case variable.
临时变量是行为类似于常规变量的变量，但不是持久变量。通常，临时变量用于高级用例。如有疑问，请使用常规案例变量。

The following applies for transient variables:
以下情况适用于临时变量：

* There is no history stored at all for transient variables.
* 临时变量根本不会存储历史记录。
* Like _regular_ variables, transient variables are put on the _highest parent_ when set. This means that when setting a variable on an plan item, the transient variable is actually stored on the case instance execution. Like regular variables, a _local_ variant of the method exists if the variable is set on the specific plan item or task.
* 与__常规__变量一样，临时变量在设置时会放在__最高级父节点__上。这意味着在方案条目上设置变量时，临时变量实际存储在案例执行实例中。与常规变量一样，如果在特定方案条目或任务上设置变量，则存在方法的__本地__变体。
* A transient variable can only be accessed before the next 'wait state' in the case definition. After that, they are gone. Here, the wait state means the point in the case instance where it is persisted to the data store.
* 临时变量只能在案例定义中的下一个“等待状态”之前访问。在那之后无法访问。在这里，等待状态表示案例实例中持久化到数据存储的时间点。
* Transient variables can only be set by the _setTransientVariable(name, value)_, but transient variables are also returned when calling _getVariable(name)_ (a _getTransientVariable(name)_ also exists, that only checks the transient variables). The reason for this is to make the writing of expressions easy and existing logic using variables works for both types.
* 临时变量只能由 _setTransientVariable(name, value)_ 设置，但在调用 _getVariable(name)_ 时也会返回临时变量（临时变量在 _getTransientVariable(name)_ 中也存在，它只检查瞬态变量）。这样做的原因是使表达式的编写变得容易，并且使用变量的现有逻辑适用于这两种变量类型。
* A transient variable _shadows_ a persistent variable with the same name. This means that when both a persistent and transient variable is set on a case instance and _getVariable("someVariable")_ is called, the transient variable value will be returned.
* 临时变量会__优先于__相同名称的持久变量。这意味着当在同一案例实例上设置相同名称的持久变量和临时变量后调用 _getVariable("someVariable")_ 时，将返回临时变量值。

You can set and get transient variables in most places where regular variables are exposed:
您可以在暴露常规变量的大多数地方设置和获取临时变量：

* On _DelegatePlanItemInstance_ in _PlanItemJavaDelegate_ implementations
* 在 _PlanItemJavaDelegate_ 实现中的 _DelegatePlanItemInstance_ 上
* When starting a case instance through the runtime service
* 通过运行时服务类启动案例实例时
* When completing a task
* 审批一个任务时

The methods follow the naming convention of the regular case variables:
这些方法遵循常规案例变量的命名约定：

[source,java,linenums]
----
CaseInstance caseInstance = runtimeService.createCaseInstanceBuilder().transientVariable("var1", "test").start();
----


[[apiExpressions]]


=== Expressions
=== 表达式

Flowable uses UEL for expression-resolving. UEL stands for _Unified Expression Language_ and is part of the EE6 specification (see link:$$http://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html$$[ the EE6 specification] for detailed information).
Flowable 使用 UEL 进行表达式解析。UEL 即 __Unified Expression Language（统一表达语言）__并且是 Java EE 6规范的一部分（详情参见 link:$$http://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html$$[Java EE6 规范] ）。

Expressions can be used in, for example, Java Service tasks, and plan item transitions. Although there are two types of expressions, value-expression and method-expression, Flowable abstracts this so they can both be used where an +expression+ is expected.
表达式可用于例如 Java 服务任务和方案条目流转。虽然有两种类型的表达式：值表达式和方法表达式，但 Flowable 对此进行了抽象，因此它们都可以在需要++表达式++的地方使用。

* *Value expression*: resolves to a value. By default, all case variables are available to use. Also, all spring-beans (if using Spring) are available to use in expressions. Some examples:
* *值表达式*：解析为一个值。默认情况下，可以使用所有案例变量。此外，所有 Spring-beans（如果使用 Spring 的话）都可用于表达式。一些例子：

----
${myVar}
${myBean.myProperty}
----


* *Method expression*: invokes a method with or without parameters. *When invoking a method without parameters, be sure to add empty parentheses after the method-name (as this distinguishes the expression from a value expression).* The passed parameters can be literal values or expressions that are resolved themselves. Examples:
* *方法表达式*：调用带或不带参数的方法。**在调用不带参数的方法时，请确保在方法名称后添加空括号（因为这会将方法表达式与值表达式区分开来）。**传递的参数可以是文本值或自己解析的表达式。例子：

----
${printer.print()}
${myBean.addNewOrder('orderName')}
${myBean.doSomething(myVar, planItemInstance)}
----

Note that these expressions support resolving primitives (including comparing them), beans, lists, arrays and maps.
请注意，这些表达式支持解析基础数据类型（包括比较它们）、Bean、列表、数组和集合。

On top of all process variables, there are a few default objects available that can be used in expressions:
除了所有流程变量之外，还有一些可用于表达式的默认对象：

* ++caseInstance++: The +DelegateCaseInstance+ holds additional information about the ongoing case instance.
* ++caseInstance++：+DelegateCaseInstance+ 拥有有关正在进行的案例实例的额外信息。
* ++planItemInstance++: The +DelegatePlanItemInstance+ holds additional information about the current plan item.
* ++planItemInstance++：+DelegatePlanItemInstance+ 拥有有关当前方案条目的额外信息。

[[cmmnExpressionsFunctions]]

=== Expression functions
=== 表达式函数

[Experimental] Expression functions have been added in version 6.4.0.
[实验]表达式函数已在6.4.0版中添加。

To make working with case variables easier, a set of out-of-the-box functions is available, under the _variables_ namespace.
为了更容易处理案例变量，在 _variables_ 命名空间下可以使用一组开箱即用的函数。

* *variables:get(varName)*: Retrieves the value of a variable. The main difference with writing the variable name directly in the expression is that using this function won't throw an exception when the variable doesn't exist. For example _${myVariable == "hello"}_ would throw an exception if _myVariable_ doesn't exist, but _${var:get(myVariable) == 'hello'}_ will just work.
* *variables:get(varName)*：检索变量的值。与直接在表达式中写入变量名称的主要区别在于，当变量不存在时，使用此函数不会抛出异常。例如，如果 myVariable 不存在，_${myVariable == "hello"}_ 将会抛出异常，而 _${var:get(myVariable) == 'hello'}_ 将正常工作。
* *variables:getOrDefault(varName, defaultValue)*: similar to _get_, but with the option of providing a default value which is returned when the variable isn't set or the value is _null_.
* *variables:getOrDefault(varName, defaultValue)*：与 _get(varName)_ 类似，但可以选择提供默认值，该值在未设置变量或值为 _null_ 时返回。
* *variables:exists(varName)*: Returns _true_ if the variable has a non-null value.
* *variables:exists(varName)*：如果变量具有非 null 值，则返回 _true_ 。
* *variables:isEmpty(varName)* (alias _:empty_) : Checks if the variable value is not empty. Depending on the variable type, the behavior is the following:
* *variables:isEmpty(varName)* （别名 _:empty_）：检查变量值是否为空。 根据变量类型，行为如下：
** For String variables, the variable is deemed empty if it's the empty string.
** 对于 String 变量，如果变量是空字符串，则该变量被视为空。
** For +java.util.Collection+ variables, _true_ is returned if the collection has no elements.
** 对于 +java.util.Collection+ 变量，如果集合没有元素，则返回 _true_。
** For +ArrayNode+ variables, _true_ is returned if there are no elements
** 对于 +ArrayNode+ 变量，如果没有元素，则返回 _true_
** In case the variable is _null_, _true_ is always returned
** 如果变量是 _null_，则始终返回 _true_
* *variables:isNotEmpty(varName)* (alias _:notEmpty_) : the reverse operation of _isEmpty_.
* *variables:isNotEmpty(varName)* （别名 _:notEmpty_）：_isEmpty(varName)_ 的取反操作。
* *variables:equals(varName, value)* (alias _:eq_) : checks if a variable is equal to a given value. This is a shorthand function for an expression that would otherwise be written as _${execution.getVariable("varName") != null && execution.getVariable("varName") == value}_.
* *variables:equals(varName, value)*（别名_ _:eq_）：检查变量是否等于给定值。这是表达式的简写函数，否则将写为 _${execution.getVariable("varName") != null && execution.getVariable("varName") == value}_。
** If the variable value is null, false is returned (unless compared to null).
** 如果变量值为 null，则返回 false（除非与 null 比较）。
* *variables:notEquals(varName, value)* (alias _:ne_) : the reverse comparison of _equals_.
* *variables:notEquals(varName, value)*（别名 _:ne_）：_equals(varName, value)_ 的取反操作。
* *variables:contains(varName, value1, value2, ...)*: checks if *all* values provided are contained within a variable. Depending on the variable type, the behavior is the following:
* *variables:contains(varName, value1, value2, ...)*: 检查提供的**所有**值是否包含在变量中。根据变量类型，行为如下：
** For String variables, the passed values are used as substrings that need to be part of the variable
** 对于 String 变量，传递的值需要全部为变量一部分子字符串
** For +java.util.Collection+ variables, all the passed values need to be an element of the collection (regular _contains_ semantics).
** 对于 +java.util.Collection+ 变量，所有传递的值都需要是集合的元素（常规 _contains_ 语义）。
** For +ArrayNode+ variables: supports checking if the arraynode contains a JsonNode for the types that are supported as variable type
** 对于 +ArrayNode+ 变量，支持检查 ArrayNode 是否包含作为变量类型支持的类型的 JsonNode
** When the variable value is null, false is returned in all cases. When the variable value is not null, and the instance type is not one of the types above, false will be returned.
** 当变量值为 null 时，在所有情况下都返回 false。如果变量值不为 null，并且实例类型不是上述类型之一，则将返回 false。
* *variables:containsAny(varName, value1, value2, ...)* : similar to the _contains_ function, but _true_ will be returned if *any* (and not all) the passed values is contained in the variable.
* *variables:containsAny(varName, value1, value2, ...)* ：类似于 _contains_ 函数，但如果**存在**（不需要全部存在）传递的值包含在变量中，则返回 _true_。
* Comparator functions:
* 比较函数：
** *variables:lowerThan(varName, value)* (alias _:lessThan_ or _:lt_) : shorthand for _${execution.getVariable("varName") != null && execution.getVariable("varName") < value}_
** *variables:lowerThan(varName, value)*（别名 _:lessThan_ 或 _:lt_）：_${execution.getVariable("varName") != null && execution.getVariable("varName") < value}_ 的简写函数。
** *variables:lowerThanOrEquals(varName, value)* (alias _:lessThanOrEquals_ or _:lte_) : similar, but now for _< =_
** *variables:lowerThanOrEquals(varName, value)*（别名 _:lessThanOrEquals_ 或 _:lte_）：与上面的类似，相当于 _< =_
** *variables:greaterThan(varName, value)* (alias _:gt_) : similar, but now for _>_
** *variables:greaterThan(varName, value)* （别名 _:gt_）：与上面的类似，相当于 _>_
** *variables:greaterThanOrEquals(varName, value)* (alias _:gte_) : similar, but now for _> =_
** *variables:greaterThanOrEquals(varName, value)* （别名 _:gte_）：与上面的类似，相当于 _> =_

The _variables_ namespace is aliased to _vars_ or _var_. So _variables:get(varName)_ is equivalent to writing _vars:get(varName)_ or _var:get(varName)_. Note that it's not needed to put quotes around the variable name: _var:get(varName)_ is equivalent to _var:get(\'varName')_ or _var:get("varName")_.
_variables_ 命名空间的别名为 _vars_ 或 _var_。因此 _variables:get(varName)_ 等同于使用 _vars:get(varName)_ 或 _var:get(varName)_。请注意，不需要再次在变量名称周围加上引号：_var:get(varName)_ 等同于 _var:get(\'varName')_ 或 _var:get("varName")_。

Also note that in none of the functions above the _planItemInstance_ or _caseInstance_ needs to be passed into the function (as would be needed when not using a function). The engine will inject the appropriate variable scope when invoking the function. This also means that these functions can be used in exactly the same way when writing expression in BPMN process definitions.
另请注意，在上述任何函数中，都不需要将 _planItemInstance_ 或 _caseInstance_ 传递给函数（它们在不使用函数时需要传递）。在调用函数时，引擎将注入适当的变量作用域。这也意味着在 BPMN 流程定义中编写表达式时，可以以完全相同的方式使用这些函数。

The use of these variable functions is especially useful in CMMN, for example when it comes to writing the condition of an if-part of sentry. Take the following CMMN case definition:
这些变量函数的使用在 CMMN 中尤其有用，例如在写入 if 部分的哨兵条件时，采用以下 CMMN 案例定义：

image::images/cmmn.expression-functions.png[align="center"]

Assume the sentry has an if-part besides the completion event. Right after a case instance is started, this if-part condition will be evaluated (as the stage becomes available). If the condition is of the form _${someVariable == someValue}_, this means the variable needs to be available when starting the case instance. In many cases, this is not possible or the variable comes later (e.g. from a form), which leads to a low-level _PropertyNotFoundException_. Taking the potential nullability in account, the correct expression would have to be:
假设哨兵除了完成事件之外还有一个 if 部分。在启动案例实例后，将评估此 if 部分条件（当此阶段变为可用时）。如果条件的形式为 _${someVariable == someValue}_，则表示该变量在启动案例实例时就将可用。在许多情况下，这是不可能的，或者变量稍后才会出现 （例如来自一个表单），这会导致一个低级的 _PropertyNotFoundException_。考虑到潜在的可空性，正确的表达必须是：

----
${planItemInstance.getVariable('someVariable') != null && planItemInstance.getVariable('someVariable') == someValue}
----

Which is quite long. Using the functions above however, this can be simplified to
这很长。但是，使用上述功能可以简化为

----
${var:eq(someVariable, someValue)}
----

or
或者

----
${var:get(someVariable) == someValue}
----

The function implementations take in account the nullability of the variable (and not throw an exception in case the variable is null) and will handle the equality correctly.
函数实现考虑了变量的可空性（并且在变量为 null 的情况下不抛出异常）并且将正确地处理相等性。

Additionally, it's possible to register custom functions that can be used in expressions. See the +org.flowable.common.engine.api.delegate.FlowableFunctionDelegate+ interface for more information.
此外，可以注册自定义函数在表达式中使用。有关更多信息，请参阅 +org.flowable.common.engine.api.delegate.FlowableFunctionDelegate+ 接口。


[[apiUnitTesting]]


=== Unit testing
=== 单元测试

Cases are an integral part of software projects and they should be tested in the same way normal application logic is tested: with unit tests.
案例是软件项目不可或缺的一部分，它们应该以与测试正常应用程序逻辑相同的方式进行测试：使用单元测试。
Since Flowable is an embeddable Java engine, writing unit tests for business cases is as simple as writing regular unit tests.
由于 Flowable 是一个嵌入式的 Java 引擎，因此为业务案例编写单元测试就像编写常规单元测试一样简单。

Flowable supports JUnit versions 4 and 5 styles of unit testing.
Flowable 支持 JUnit 4、JUnit 5 做单元测试。

In the JUnit 5 style one needs to use the +org.flowable.cmmn.engine.test.FlowableCmmnTest+ annotation or register the +org.flowable.cmmn.engine.test.FlowableCmmnExtension+ manually.
在 JUnit 5中，需要使用 +org.flowable.cmmn.engine.test.FlowableCmmnTest+ 注解或手动注册 +org.flowable.cmmn.engine.test.FlowableCmmnExtension+。
The +FlowableCmmnTest+ annotation is just a meta annotation and the does the registration of the +FlowableCmmnExtension+ (i.e. it does +@ExtendWith(FlowableCmmnExtension.class)+).
+FlowableCmmnTest+ 注释是一个元注释，实现了对 +FlowableCmmnExtension+ 的注册（即它实现了 +@ExtendWith(FlowableCmmnExtension.class)+）。
This will make the CmmnEngine and the services available as parameters into the test and lifecycle methods (+@BeforeAll+, +@BeforeEach+, +@AfterEach+, +@AfterAll+).
这将使 CmmnEngine 和其服务类可用作测试和生命周期方法的参数（+@BeforeAll+、+@BeforeEach+、+@AfterEach+、+@AfterAll+）。
Before each test the cmmnEngine will be initialized by default with the +flowable.cmmn.cfg.xml+ resource on the classpath.
在每次测试之前，默认会使用类路径上的 +flowable.cmmn.cfg.xml+ 配置文件初始化 CmmnEngine。
In order to specify a different configuration file the +org.flowable.cmmn.engine.test.CmmnConfigurationResource+ annotation needs to be used (see second example).
为了指定不同的配置文件，需要使用 +org.flowable.cmmn.engine.test.CmmnConfigurationResource+ 注解（参见第二个示例）。
Cmmn engines are cached statically over multiple unit tests when the configuration resource is the same.
使用相同的配置文件时，CMMN 引擎会在多个单元测试之间静态缓存。

By using +FlowableCmmnExtension+, you can annotate test methods with +org.flowable.cmmn.engine.test.CmmnDeployment+.
通过使用 +FlowableCmmnExtension+，您可以对测试方法使用 +org.flowable.cmmn.engine.test.CmmnDeployment+ 注解。
When a test method is annotated with +@CmmnDeployment+, before each test the cmmn files defined in +CmmnDeployment#resources+ will be deployed.
当使用有 +@CmmnDeployment+ 注解的测试方法时，在每次测试之前，将会发布在 +CmmnDeployment#resources+ 下定义的 cmmn 文件。
In case there are no resources defined, a resource file of the form +testClassName.testMethod.cmmn+ in the same package as the test class, will be deployed.
如果没有定义资源，将发布与测试类在同一包中的 +testClassName.testMethod.cmmn+ 形式的资源文件。
At the end of the test, the deployment will be deleted, including all related case instances, tasks, and so on.
在测试结束时，部署文件将会删除，包括所有相关的案例实例、定义等。
See the +CmmnDeployment+ class for more information.
有关更多信息，请参阅 ++CmmnDeployment++ 类。

Taking all that in account, a JUnit 5 test looks as follows:
考虑到所有这些，JUnit 5单元测试看起来如下：

.Junit 5 test with default resource
.使用默认配置文件的 Junit 5 单元测试
[source,java,linenums]
----
@FlowableCmmnTest
class MyTest {

  private CmmnEngine cmmnEngine;
  private CmmnRuntimeService cmmnRuntimeService;
  private CmmnTaskService cmmnTaskService;

  @BeforeEach
  void setUp(CmmnEngine cmmnEngine) {
    this.cmmnEngine = cmmnEngine;
    this.cmmnRuntimeService = cmmnEngine.getCmmnRuntimeService();
    this.cmmnTaskService = cmmnEngine.getTaskRuntimeService();
  }

  @Test
  @CmmnDeployment
  void testSingleHumanTask() {
    CaseInstance caseInstance = cmmnRuntimeService.createCaseInstanceBuilder()
                    .caseDefinitionKey("myCase")
                    .start();
	assertNotNull(caseInstance);

    Task task = cmmnTaskService.createTaskQuery().caseInstanceId(caseInstance.getId()).singleResult();
    assertEquals("Task 1", task.getName());
    assertEquals("JohnDoe", task.getAssignee());

    cmmnTaskService.complete(task.getId());
    assertEquals(0, cmmnRuntimeService.createCaseInstanceQuery().count());
  }
}
----

-----
With JUnit 5 you can also inject the id of the deployment (with +org.flowable.cmmn.engine.test.CmmnDeploymentId+_) into your test and lifecycle methods.
使用 JUnit 5，您还可以将部署文件的 ID（使用 org.flowable.cmmn.engine.test.CmmnDeploymentId）注入到测试和生命周期方法中。
-----

.Junit 5 test with custom resource
.使用自定义配置文件的Junit 5单元测试
[source,java,linenums]
----
@FlowableCmmnTest
@CmmnConfigurationResource("flowable.custom.cmmn.cfg.xml")
class MyTest {

  private CmmnEngine cmmnEngine;
  private CmmnRuntimeService cmmnRuntimeService;
  private CmmnTaskService cmmnTaskService;

  @BeforeEach
  void setUp(CmmnEngine cmmnEngine) {
    this.cmmnEngine = cmmnEngine;
    this.cmmnRuntimeService = cmmnEngine.getCmmnRuntimeService();
    this.cmmnTaskService = cmmnEngine.getTaskRuntimeService();
  }
  @Test
  @CmmnDeployment
  void testSingleHumanTask() {
    CaseInstance caseInstance = cmmnRuntimeService.createCaseInstanceBuilder()
                    .caseDefinitionKey("myCase")
                    .start();
	assertNotNull(caseInstance);

    Task task = cmmnTaskService.createTaskQuery().caseInstanceId(caseInstance.getId()).singleResult();
    assertEquals("Task 1", task.getName());
    assertEquals("JohnDoe", task.getAssignee());

    cmmnTaskService.complete(task.getId());
    assertEquals(0, cmmnRuntimeService.createCaseInstanceQuery().count());
  }
}
----

In the JUnit 4 style, the _org.flowable.cmmn.engine.test.FlowableCmmnTestCase_ is available as parent class. It uses a configuration file _flowable.cmmn.cfg.xml_ by default or uses a standard CmmnEngine using an H2 in-memory database if such file is missing.
在 JUnit 4 中，_org.flowable.cmmn.engine.test.FlowableCmmnTestCase_ 可用作父类。它默认使用 _flowable.cmmn.cfg.xml_ 配置文件，如果缺少此类文件，则使用连接 H2 内存数据库的标准 CmmnEngine。
Behind the scenes, a CmmnTestRunner is used to initialise the CMMN engine. Note in the example below how the _@CmmnDeployment_ annotation is used to automatically deploy the case definition (it will look for a .cmmn file in the same folder as the test class and expects the file to be named <Test class name>.<test method name>.cmmn.
在后台，CmmnTestRunner 用于初始化 CMMN 引擎。请注意下面的示例中如何使用 _@CmmnDeployment_ 注解自动部署案例定义（它将在与测试类相同的文件夹中查找 .cmmn 文件，并期望文件名为<测试类名>.<测试方法名称>.cmmn）。

[source,java,linenums]
----

public class MyTest extends FlowableCmmnTestCase {

  @Test
  @CmmnDeployment
  public void testSingleHumanTask() {
    CaseInstance caseInstance = cmmnRuntimeService.createCaseInstanceBuilder()
                    .caseDefinitionKey("myCase")
                    .start();
	assertNotNull(caseInstance);

    Task task = cmmnTaskService.createTaskQuery().caseInstanceId(caseInstance.getId()).singleResult();
    assertEquals("Task 1", task.getName());
    assertEquals("JohnDoe", task.getAssignee());
        
    cmmnTaskService.complete(task.getId());
    assertEquals(0, cmmnRuntimeService.createCaseInstanceQuery().count());
  }
}
----

Alternatively, the _FlowableCmmnRule_ is available and allows to set a custom configuration:
此外，使用 _FlowableCmmnRule_ 并允许设置自定义配置：

.JUnit 4 test with a Rule
.规则相关的 JUnit 4 单元测试
[source,java,linenums]
----
@Rule
public FlowableCmmnRule cmmnRule = new FlowableCmmnRule("org/flowable/custom.cfg.xml")

@Test
@CmmnDeployment
public void testSomething() {
    // ...
    assertThat((String) cmmnRule.getCmmnRuntimeService().getVariable(caseInstance.getId(), "test"), containsString("John"));
    // ...
}
----    

