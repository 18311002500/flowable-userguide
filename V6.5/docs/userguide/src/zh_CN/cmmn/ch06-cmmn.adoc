== CMMN 1.1

=== What is CMMN?
=== 什么是 CMMN?

The Case Management Model and Notation (CMMN) is a standard notation and formal specification by the link:$$http://www.omg.org/spec/CMMN/$$[Object Management Group] for representing case models.

案例管理模型和标记法是由link:$$http://www.omg.org/spec/CMMN/$$[对象管理组织(Object Management Group,缩写为OMG)]为了表示案例模型而建立的标准规范.

Flowable contains:

Flowable 包含:

* A CMMN 1.1 modeler to create CMMN 1.1 case models

* 一个基于CMMN1.1的模型设计器用来创建案例模型

* A Java engine that can import and execute CMMN 1.1 case models

* 一个JAVA引擎用来导入并运行CMMN1.1案例模型

* A demonstration UI that executes the case models, allowing users to see and complete human tasks (and their forms)

* 一个动态前端页面用来执行案例模型,并允许用户查看并完成相关任务和对应表单

=== Basic concepts and terminology

=== 基础概念和术语

The following figure shows a simple CMMN 1.1 diagram:

以下内容展示了一个简单的CMMN1.1图:

image::images/cmmn-basic-concepts.png[align="center"]

A *case model* is always visualized as some sort of _folder_ that contains all the case elements. Every case model contains a *plan model* onto which items will be _planned_. 

一个 *案例模型* 通常被看作一个包含所有的案例元素的 _文件夹_. 每个案例模型包含一个 *计划模型* ,其他所有的元素放在该计划模型内部.

The elements of a plan model are called *plan items*. Each _plan item_ has a *plan item definition* that gives its type and possible configuration options at runtime. For example, in the figure above, there are three *human task* plan items and one *milestone*. Other examples of plan items are _process tasks, case tasks and stages_.

一个计划模型中所有元素被称为 *计划项*. 每个计划项都一个类型及运行时相关配置项的定义.例如,上图中,有三个人工任务和一个里程碑.其他的计划项分别有 _流程任务、案例任务和阶段_.

After having deployed a case model to the Flowable CMMN engine, it's possible to start *case instances* based on this case model. The plan items defined in the case model similarly have *plan item instance* runtime representations that are exposed by, and can be queried using, the Flowable API. Plan item instances have a state lifecycle that is defined in the CMMN 1.1 specification and is core to how the engine works. Please check out section 8.4.2 of the CMMN 1.1 specification for all the details.

当把一个案例模型在Flowable CMMN引擎上部署完成后, 很可能就直接启动一个基于此模型的实例. 其中的定义的计划项同样也会产成运行时的实例并且暴露出来,通过使用Flowable API可以查询得到. *计划项实例* 拥有基于CMMN 1.1规范定义的生命周期状态, 并且是整个引擎工作的核心. 详细内容请查阅 CMMN1.1规范的8.4.2部分.

Plan items can have _sentries_: a plan item is said to have _entry criteria_ when a sentry "guards" its activation. These criteria specify conditions that must be satisfied to _trigger the sentry_. For example, in the figure above, the "Milestone One" plan item is _available_ after a case instance is started, but it is _activated_ (in CMMN 1.1 specification terminology: it moves from the _available_ state to the _active_ state) when both human task A and B are completed. Note that sentries can have complex expression in their _if part_, which are not visualized, allowing for much more complex functionality. Also note that there can be multiple sentries, although only one needs to be satisfied to trigger a state transition.

计划项可以拥有 _哨兵_: 当使用哨兵守卫它的激活, 这个计划项相当于拥有入口凭证.这些凭证明确了触发哨兵需要满足的条件.例如,在上图中,里程碑在一个案例实例启动后为可用状态,但是当人工任务A和人工任务B都完成后,该里程碑状态由可用状态变成激活状态.注意守卫可以在它的条件中使用不可见的复杂表达式,以便完成更多复杂的功能.同样,也可以拥有多个守卫,只需满足一个哨兵就可以出发状态的转变.

Plan items and the plan model can also have sentries with _exit criteria_, which specify conditions that trigger an _exit_ from that particular plan item. In the figure above, the whole plan model is exited (as are all the child elements that are active at that moment), when human task C completes.

计划项和计划模型也可以拥有退出凭证的哨兵,其明确了从对应计划项退出的条件.在上图中,当人工任务C完成后,整个计划模型(包括此刻所有激活状态的子元素)将会退出.


CMMN 1.1 defines a standard XML format in an XSD that is part of the specification. For information, the example in the figure above is represented in XML as shown below.

CMMN 1.1在XSD中定义作为规范一部分的XML标准格式. 已供参阅, 下面展示的XML代表了上述例子的案例图.

Some observations:

一些结论:

* The four plan items above are in the XML and they reference their definition with a _definitionRef_. The actual definitions are at the bottom of the _casePlanModel_ element

* XML中的四个计划项通过使用 _definitionRef_ 属性关联它们自身的定义. 实际的声明是在底部的 _casePlanModel_ 元素

* The plan items have criteria (entry or exit) that reference a _sentry_ (not the other way around)

* 拥有进入或退出凭证的计划项关联一个 _sentry_ 哨兵(而不是反过来)

* The XML also contains information on how the diagram is visualized (x and y coordinates, widths and heights, and so on), which are omitted below. These elements are important when exchanging case models with other CMMN 1.1 modeling tools to preserve the correct visual representation

* XML也包含可见案例图的信息(x 和 y坐标, 宽度和高度等等),在以下展示中已省略. 当使用其他 CMMN 1.1 模型工具用来保存正确的可视化案例图时,这些信息是重要的.

[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://www.omg.org/spec/CMMN/20151109/MODEL" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
             xmlns:flowable="http://flowable.org/cmmn" 
             xmlns:cmmndi="http://www.omg.org/spec/CMMN/20151109/CMMNDI" 
             xmlns:dc="http://www.omg.org/spec/CMMN/20151109/DC" 
             xmlns:di="http://www.omg.org/spec/CMMN/20151109/DI" 
             targetNamespace="http://www.flowable.org/casedef">
  <case id="simpleExample" name="Simple Example">
    <casePlanModel id="casePlanModel" name="My Case">
      <planItem id="planItem1" name="Human task A" 
            definitionRef="sid-88199E7C-7655-439C-810B-8849FC52D3EB"></planItem>
      <planItem id="planItem2" name="Milestone One" 
            definitionRef="sid-8BF8A774-A8A7-4F1A-95CF-1E0D61EE5A47">
        <entryCriterion id="sid-62CC4A6D-B29B-4129-93EA-460253C45CDF" 
            sentryRef="sentry1"></entryCriterion>
      </planItem>
      <planItem id="planItem3" name="Human task B" 
            definitionRef="sid-A1FB8733-0DBC-4B38-9830-CBC4D0C4B802"></planItem>
      <planItem id="planItem4" name="Human task C" 
            definitionRef="sid-D3970AFC-7391-4BA7-95BA-51C64D2F41E9"></planItem>
      <sentry id="sentry1">
        <planItemOnPart id="sentryOnPart1" sourceRef="planItem1">
          <standardEvent>complete</standardEvent>
        </planItemOnPart>
        <planItemOnPart id="sentryOnPart2" sourceRef="planItem3">
          <standardEvent>complete</standardEvent>
        </planItemOnPart>
      </sentry>
      <sentry id="sentry2">
        <planItemOnPart id="sentryOnPart3" sourceRef="planItem4">
          <standardEvent>complete</standardEvent>
        </planItemOnPart>
      </sentry>
      <humanTask id="sid-88199E7C-7655-439C-810B-8849FC52D3EB" 
        name="Human task A"></humanTask>
      <milestone id="sid-8BF8A774-A8A7-4F1A-95CF-1E0D61EE5A47" 
        name="Milestone One"></milestone>
      <humanTask id="sid-A1FB8733-0DBC-4B38-9830-CBC4D0C4B802" 
        name="Human task B"></humanTask>
      <humanTask id="sid-D3970AFC-7391-4BA7-95BA-51C64D2F41E9" 
        name="Human task C"></humanTask>
      <exitCriterion id="sid-422626DB-9B40-49D8-955E-641AB96A5BFA" 
        sentryRef="sentry2"></exitCriterion>
    </casePlanModel>
  </case>
  <cmmndi:CMMNDI>
    <cmmndi:CMMNDiagram id="CMMNDiagram_simpleExample">
        ...
    </cmmndi:CMMNDiagram>
  </cmmndi:CMMNDI>
</definitions>
----

=== Programmatic example

=== 程序示例

In this section we're going to build a simple case model and execute it programmatically through the Java APIs of the Flowable CMMN engine in a simple command line example.

在这个小节, 我们将会用代码构建并执行一个简单的案例模型, 通过在命令行中调用Flowable CMMN engine的Java API.

The case model we'll build is a simplified _employee onboarding_ case with two stages: a phase before and phase after the potential employee has started. In the first stage, someone from the HR department will complete the tasks, while in the second stage it is the employee completing them. Also, at any point in time, the potential employee can reject the job and stop the whole case instance.

在这个案例模型中, 我们将构建一个简化的有两个阶段的 _employee onboarding_ 案例: 两个时期分别在的员工入职前后.第一个阶段,HR部门中的某个人将会完成相关任务;第二个阶段,该员工完成它们.同时,在任何时间,该试用员工可以拒绝这份工作并且停止这个实例.

Note that only stages and human tasks are used. In a real case model, there will most likely other plan item types too, such as milestones, nested stages, automated tasks, and so on.

注意, 只有 stages and human tasks 被用到. 在真实案例模型中, 很可能会有其他类型的计划项,比如里程碑, 嵌套stage, 自动化任务等等.

image::images/cmmn.programmatic.example.png[align="center"]

The XML for this case model is the following:

这个案例模型的XML如下所示:

[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://www.omg.org/spec/CMMN/20151109/MODEL" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
             xmlns:flowable="http://flowable.org/cmmn" 
             xmlns:cmmndi="http://www.omg.org/spec/CMMN/20151109/CMMNDI" 
             xmlns:dc="http://www.omg.org/spec/CMMN/20151109/DC" 
             xmlns:di="http://www.omg.org/spec/CMMN/20151109/DI" 
             targetNamespace="http://www.flowable.org/casedef">
  <case id="employeeOnboarding" name="Simple Example">
    <casePlanModel id="casePlanModel" name="My Case">
      <planItem id="planItem5" name="Prior to starting" 
            definitionRef="sid-025D29E8-BA9B-403D-A684-8C5B52185642"></planItem>
      <planItem id="planItem8" name="After starting" 
            definitionRef="sid-8459EF32-4F4C-4E9B-A6E9-87FDC2299044">
        <entryCriterion id="sid-50B5F12D-FE75-4D05-9148-86574EE6C073" 
            sentryRef="sentry2"></entryCriterion>
      </planItem>
      <planItem id="planItem9" name="Reject job" 
            definitionRef="sid-134E885A-3D58-417E-81E2-66A3E12334F9"></planItem>
      <sentry id="sentry2">
        <planItemOnPart id="sentryOnPart4" sourceRef="planItem5">
          <standardEvent>complete</standardEvent>
        </planItemOnPart>
      </sentry>
      <sentry id="sentry3">
        <planItemOnPart id="sentryOnPart5" sourceRef="planItem9">
          <standardEvent>complete</standardEvent>
        </planItemOnPart>
      </sentry>
      <stage id="sid-025D29E8-BA9B-403D-A684-8C5B52185642" name="Prior to starting">
        <planItem id="planItem1" name="Create email address" 
                definitionRef="sid-EA434DDD-E1BE-4AC1-8520-B19ACE8782D2"></planItem>
        <planItem id="planItem2" name="Allocate office" 
                definitionRef="sid-505BA223-131A-4EF0-ABAD-485AEB0F2C96"></planItem>
        <planItem id="planItem3" name="Send joining letter to candidate" 
                definitionRef="sid-D28DBAD5-0F5F-45F4-8553-3381199AC45F">
          <entryCriterion id="sid-4D88C79D-8E31-4246-9541-A4F6A5720AC8" 
            sentryRef="sentry1"></entryCriterion>
        </planItem>
        <planItem id="planItem4" name="Agree start date" 
                definitionRef="sid-97A72C46-C0AD-477F-86DD-85EF643BB97D"></planItem>
        <sentry id="sentry1">
          <planItemOnPart id="sentryOnPart1" sourceRef="planItem1">
            <standardEvent>complete</standardEvent>
          </planItemOnPart>
          <planItemOnPart id="sentryOnPart2" sourceRef="planItem2">
            <standardEvent>complete</standardEvent>
          </planItemOnPart>
          <planItemOnPart id="sentryOnPart3" sourceRef="planItem4">
            <standardEvent>complete</standardEvent>
          </planItemOnPart>
        </sentry>
        <humanTask id="sid-EA434DDD-E1BE-4AC1-8520-B19ACE8782D2" 
            name="Create email address" 
            flowable:candidateGroups="hr"></humanTask>
        <humanTask id="sid-505BA223-131A-4EF0-ABAD-485AEB0F2C96" 
            name="Allocate office" 
            flowable:candidateGroups="hr"></humanTask>
        <humanTask id="sid-D28DBAD5-0F5F-45F4-8553-3381199AC45F" 
            name="Send joining letter to candidate" 
            flowable:candidateGroups="hr"></humanTask>
        <humanTask id="sid-97A72C46-C0AD-477F-86DD-85EF643BB97D" 
            name="Agree start date" 
            flowable:candidateGroups="hr"></humanTask>
      </stage>
      <stage id="sid-8459EF32-4F4C-4E9B-A6E9-87FDC2299044" 
        name="After starting">
        <planItem id="planItem6" name="New starter training" 
                definitionRef="sid-DF7B9582-11A6-40B4-B7E5-EC7AC6029387"></planItem>
        <planItem id="planItem7" name="Fill in paperwork" 
                definitionRef="sid-7BF2B421-7FA0-479D-A8BD-C22EBD09F599"></planItem>
        <humanTask id="sid-DF7B9582-11A6-40B4-B7E5-EC7AC6029387" 
            name="New starter training" 
            flowable:assignee="${potentialEmployee}"></humanTask>
        <humanTask id="sid-7BF2B421-7FA0-479D-A8BD-C22EBD09F599" 
            name="Fill in paperwork" 
            flowable:assignee="${potentialEmployee}"></humanTask>
      </stage>
      <humanTask id="sid-134E885A-3D58-417E-81E2-66A3E12334F9" name="Reject job" 
        flowable:assignee="${potentialEmployee}"></humanTask>
      <exitCriterion id="sid-18277F30-E146-4B3E-B3C9-3F1E187EC7A8" 
        sentryRef="sentry3"></exitCriterion>
    </casePlanModel>
  </case>
</definitions>
----

First of all, create a new project and add the _flowable-cmmn-engine_ dependency (here shown for Maven). The H2 dependency is also added, as H2 will be used as embedded database later on.

首先, 创建一个新的工程, 添加 _flowable-cmmn-engine_ 依赖(这里展示了Maven), H2 数据库依赖也要添加, 后续将会使用 H2 作为内嵌的数据库.

[source,xml,linenums]
----
<dependency>
    <groupId>org.flowable</groupId>
    <artifactId>flowable-cmmn-engine</artifactId>
    <version>${flowable.version}</version>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>${h2.version}</version>
</dependency>
----

The Flowable CMMN API is designed to be consistent with the other Flowable APIs and concepts. As such, people that know the BPMN or DMN APIs will have no problem finding their way around. As with the other engines, the first line of code is creating a CmmnEngine. Here, the default in-memory configuration is used, which uses H2 as the database:

The Flowable CMMN API 包括了其他的 Flowable APIs 和相关概念. 同样,熟悉 BPMN 或者 DMN APIs的人很容易上手.和其他引擎一样, 第一行代码是创建一个 Cmmn引擎. 这里,默认的配置将会使用 H2作为内存数据库:

[source,java,linenums]
----
public class Main {
  public static void main(String[] args) {
    CmmnEngine cmmnEngine 
        = new StandaloneInMemCmmnEngineConfiguration().buildCmmnEngine();
  }
}
----

Note that the _CmmnEngineConfiguration_ exposes many configuration options for tweaking various settings of the CMMN engine.

注意_CmmnEngineConfiguration_ 提供了很多配置项来调整 CMMN引擎的设置.

Put the XML from above in a file, for example _my-case.cmmn_ (or .cmmn.xml). For Maven, it should be placed in the _src/main/resources_ folder.

把上述 XML 放入一个文件中, 例如 _my-case.cmmn_ (or .cmmn.xml). 对于Maven工程, 应该放在 _src/main/resources_ 文件夹中.

To make the engine aware of the case model, it first needs to be _deployed_. This is done through the _CmmnRepositoryService_:

为了使引擎感知当前案例模型, 它首先需要被部署 _deployed_. 这个工作由 the _CmmnRepositoryService_ 完成:

[source,java,linenums]
----
CmmnRepositoryService cmmnRepositoryService = cmmnEngine.getCmmnRepositoryService();
CmmnDeployment cmmnDeployment = cmmnRepositoryService.createDeployment()
    .addClasspathResource("my-case.cmmn")
    .deploy();
----

Deploying the XML will return a *CmmnDeployment*. A deployment can contain many case models and artifacts. The specific case model definition above is stored as a *CaseDefinition*. This can be verified by doing a _CaseDefinitionQuery_:

当部署XML时, 会返回一个 *CmmnDeployment*. 一个 deployment 包含多个案例模型和目标. 一个明确的案例模型定义被存储成一个案例定义 *CaseDefinition*. 这可以通过执行 _CaseDefinitionQuery_ 案例定义查询 来验证:

[source,java,linenums]
----
List<CaseDefinition> caseDefinitions = cmmnRepositoryService.createCaseDefinitionQuery().list();
System.out.println("Found " + caseDefinitions.size() + " case definitions");
----

Having a *CaseDefinition* in the engine, it's now possible to start a *CaseInstance* for this case model definition. Either the result from the query is used and passed into the following snippet of code, or the _key_ of the case definition is used directly (as done below).

当在引擎中拥有一个案例定义后, 现在可以启动一个对应 *CaseInstance* 案例实例. 要么使用查询后的结果并传递给下面的代码片段中, 要么直接使用 the case definition的key(如下所示).


Note that we're also passing data, an identifier to the _potentialEmployee_ as a variable when starting the *CaseInstance*. This variable will later be used in the human tasks to assign the task to the correct person (see the _assignee="${potentialEmployee}"_ attribute on _human tasks_).

注意当启动 *CaseInstance*, 我们也传递了 _potentialEmployee_ 作为一个标记, 这个变量之后会被用作人工任务的指派(see the _assignee="${potentialEmployee}"_ attribute on _human tasks_)

[source,java,linenums]
----
CmmnRuntimeService cmmnRuntimeService = cmmnEngine.getCmmnRuntimeService();
CaseInstance caseInstance = cmmnRuntimeService.createCaseInstanceBuilder()
    .caseDefinitionKey("employeeOnboarding")
    .variable("potentialEmployee", "johnDoe")
    .start();
----

After the *CaseInstance* is started, the engine will determine which of the plan items of the model should be activated:

当 *CaseInstance* 启动后, 引擎将决定哪一个计划项应该被激活:

* The first stage has no entry criteria, so it's activated

* 第一个阶段没有入口凭证, 所以它会被激活

* The child human tasks of the first stage have no entry criteria, so three of them are expected to be active

* 第一个阶段的子人工任务没有入口凭证, 所以它们三个也预计被激活

The plan items are represented at runtime by *PlanItemInstances* and can be queried through the _CmmnRuntimeService_:

在运行时, 计划项被当做 *PlanItemInstances*, 可以使用 _CmmnRuntimeService_ 查询获取:

[source,java,linenums]
----
List<PlanItemInstance> planItemInstances = cmmnRuntimeService.createPlanItemInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .orderByName().asc()
    .list();

for (PlanItemInstance planItemInstance : planItemInstances) {
    System.out.println(planItemInstance.getName());
}
----

which prints out

打印如下:

----
After starting
Agree start date
Allocate office
Create email address
Prior to starting
Reject job
Send joining letter to candidate
----

Some things might be unexpected here:

上述打印结果中有些事情可能出乎意料:

* The stages are _also_ plan items and thus have a representation as *PlanItemInstance*. Note that that child plan item instances will have the stage as parent when calling _.getStageInstanceId()_.

* stages 也是属于 计划项, 同样被当做 *PlanItemInstance*. 注意当调用 _.getStageInstanceId()_ ,子计划项实例也会拥有stage作为父类.

* The _Send joining letter to candidate_ is returned in the result. The reason is that, in accordance with the CMMN 1.1 specification, this plan item instance is in the _available_ state, but not yet in the _active_ state.

* _Send joining letter to candidate_ 也在返回结果集中.原因是因为依据 CMMN 1.1 规范, 这个计划项实例是出于可用状态, 而不是处于激活状态.

Indeed, when the code above is changed to

进一步, 修改上述代码:

[source,java,linenums]
----
for (PlanItemInstance planItemInstance : planItemInstances) {
    System.out.println(planItemInstance.getName() 
        + ", state=" + planItemInstance.getState() 
        + ", parent stage=" + planItemInstance.getStageInstanceId());
}
----

The output now becomes:

现在输出如下:

----
After starting, state=available, parent stage=null
Agree start date, state=active, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
Allocate office, state=active, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
Create email address, state=active, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
Prior to starting, state=active, parent stage=null
Reject job, state=active, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
Send joining letter to candidate, state=available, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
----

To only show the active plan item instances, the query can be adapted by adding _planItemInstanceStateActive()_:

为了只显示激活状态的计划项实例, 查询可以调整并增加 _planItemInstanceStateActive()_ 方法:

[source,java,linenums]
----
 List<PlanItemInstance> planItemInstances = cmmnRuntimeService.createPlanItemInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .planItemInstanceStateActive()
    .orderByName().asc()
    .list();
----

The output is now

现在输出如下:

----
Agree start date
Allocate office
Create email address
Prior to starting
Reject job
----

Of course, the *PlanItemInstance* is the low level representation, but each plan item also has a _plan item definition_ that defines what type it is. In this case, we only have _human tasks_. It is possible to interact with the _CaseInstance_ via its _plan item instances_, for example by triggering them programmatically (for example, _CmmnRuntimeService.triggerPlanItemInstance(String planItemInstanceId)_). However, most likely the interaction will happen through the results of the actual plan item definition: here, the human tasks.

当然, *PlanItemInstance* 是 低级别的表示, 但是每个计划项也拥有一个  _plan item definition_  明确其类型. 在这个例子中, 我们只有 _human tasks_.通过使用 计划项实例 来影响整个 案例实例,
(比如, _CmmnRuntimeService.triggerPlanItemInstance(String planItemInstanceId)_).然而, 交互最有可能通过实际计划项定义的结果发生: 比如这里的人工任务.

Querying for tasks is done in the exact same way as for the BPMN engine (in fact, the task service is a shared component and tasks created in BPMN or CMMN can be queried through both engines):

任务的查询方法和BPMN 引擎一样, (实际上, 任务服务是一个共享的组件, BPMN或者CMMN创建的任务都可以通过各自引擎查询得到):

[source,java,linenums]
----
CmmnTaskService cmmnTaskService = cmmnEngine.getCmmnTaskService();
List<Task> hrTasks = cmmnTaskService.createTaskQuery()
    .taskCandidateGroup("hr")
    .caseInstanceId(caseInstance.getId())
    .orderByTaskName().asc()
    .list();
for (Task task : hrTasks) {
    System.out.println("Task for HR : " + task.getName());
}
        
List<Task> employeeTasks = cmmnTaskService.createTaskQuery()
    .taskAssignee("johndoe")
    .orderByTaskName().asc()
    .list();
for (Task task : employeeTasks) {
    System.out.println("Task for employee: " + task);
}
----

Which outputs:

上述输出:

----
Task for HR : Agree start date
Task for HR : Allocate office
Task for HR : Create email address

Task for employee: Reject job
----

When the three tasks of HR are completed, the 'Send joining letter to candidate' task should be available:

当HR的三个任务都完成, 给求职者发送入职信的任务应该是可用的:

[source,java,linenums]
----
for (Task task : hrTasks) {
    cmmnTaskService.complete(task.getId());
}

hrTasks = cmmnTaskService.createTaskQuery()
    .taskCandidateGroup("hr")
    .caseInstanceId(caseInstance.getId())
    .orderByTaskName().asc()
    .list();

for (Task task : hrTasks) {
    System.out.println("Task for HR : " + task.getName());
}
----

And indeed, the expected task is now created:

事实上, 预期的任务现在被创建了:

----
Task for HR : Send joining letter to candidate
----

Completing this task will now move the case instance into the second stage, as the sentry for the first stage is satisfied. The 'Reject job' tasks is automatically completed by the system and the two tasks for the employee are created:

完成这个任务,案例实例将进入第二个阶段, 同时第一阶段的哨兵的条件得到满足. 'Reject job'任务被程序自动创建, 并且指派给员工的两个任务也被创建:

[source,java,linenums]
----
Task for employee: Fill in paperwork
Task for employee: New starter training
Task for employee: Reject job
----

Completing all the tasks will end the case instance:

完成所有任务将结束整个案例实例:

----
List<Task> tasks = cmmnTaskService.createTaskQuery().caseInstanceId(caseInstance.getId()).listPage(0, 1);
while (!tasks.isEmpty()) {
    cmmnTaskService.complete(tasks.get(0).getId());
    tasks = cmmnTaskService.createTaskQuery()
        .caseInstanceId(caseInstance.getId())
        .listPage(0, 1);
}
----

While executing case instances, the engine also stores historic information, which can be queried via a query API:

当执行案例实例时, 引擎也会保存历史信息, 这可以通过查询API获取:

[source,java,linenums]
----
CmmnHistoryService cmmnHistoryService = cmmnEngine.getCmmnHistoryService();
HistoricCaseInstance historicCaseInstance = cmmnHistoryService.createHistoricCaseInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .singleResult();

System.out.println("Case instance execution took " 
    + (historicCaseInstance.getEndTime().getTime() - historicCaseInstance.getStartTime().getTime()) + " ms");
        
List<HistoricTaskInstance> historicTaskInstances = cmmnHistoryService.createHistoricTaskInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .orderByTaskCreateTime().asc()
    .list();

for (HistoricTaskInstance historicTaskInstance : historicTaskInstances) {
    System.out.println("Task completed: " + historicTaskInstance.getName());
}
----

Which outputs:

输出如下:

----
Case instance execution took 149 ms
Task completed: Reject job
Task completed: Agree start date
Task completed: Allocate office
Task completed: Create email address
Task completed: Send joining letter to candidate
Task completed: New starter training
Task completed: Fill in paperwork
----

Historic data related to the case execution is collected for special constructs, such as Tasks (as seen above), milestones, cases, variables and plan items in general.
This data is persisted at the same time as the runtime data, but it is not deleted when case instances end.
Access to the historic data is provided as query APIs by the _CmmnHistoryService_

案例执行相关的历史数据以特殊的结构被收集, 比如 Tasks (上面所见的), milestones, cases, variables and 一般的 plan items.
这个数据作为运行时数据被持久化, 但是不会在实例结束后被删除.访问历史数据可以通过 _CmmnHistoryService_ 的相关API


Of course, this is but a small part of the available APIs and constructs available in the Flowable CMMN Engine. Please check the other sections for more detailed information

当然, 这只是Flowable CMMN Engine所有可用的APIs中的一小部分,请查阅其他章节了解更多详情

=== CMMN 1.1 Constructs

This chapter covers the CMMN 1.1 constructs supported by Flowable, as well as extensions to the CMMN 1.1 standard.

这个小节 覆盖了 Flowable支持的 CMMN 1.1设计, 同时也是对 CMMN 1.1 标准的拓展

The following constructs, with the exception of sentries and item control, as for the CMMN specification are considered plan items.
Historic data of their instances execution can be queried through the _CmmnHistoryService_ using _org.flowable.cmmn.api.history.HistoricPlanItemInstanceQuery_.

下述设计, 除了哨兵和item 控制, 都是依据 CMMN规范中的计划项作为参考.它们实例执行的历史数据可用通过 _CmmnHistoryService_ 使用 _org.flowable.cmmn.api.history.HistoricPlanItemInstanceQuery_ 方法获取.

==== Stage

==== 阶段

A stage is used to group plan items together. It is typically used to define "phases" in a case instance.

一个 stage 被看作一组计划项的集合, 它通常用于在案例实例中定义"阶段"

A stage is a plan item itself, and thus can have entry and exit criteria. Plan items contained within a stage are only available when the parent stage moves to the _active_ state. Stages can be nested in other stages.

一个 stage 本事也是计划项, 也拥有进入和退出凭证. 计划项以及它包含的计划项只有在计入激活状态才可用, stage 可以内嵌在其他stage中.

A stage is visualized as a rectangle with angled corners:

a stage 可以看作是一个有尖角的矩形

image::images/cmmn.stage.png[align="center"]

==== Task

==== 任务

A "manual" task, meaning the task will happen external to the engine.

一个手动任务, 意味着它将在引擎外部发生.

Properties:

* *name*: expression that will be resolved at runtime as the name of the manual task

* *name*: 表达式将会在运行时被解析当做任务名称

* *blocking*: a boolean value determining whether the task blocks

* *blocking*: 布尔值决定是否任务被阻塞

* *blockingExpression*: an expression that evaluates to a boolean indicating whether the tasks blocks

* *blockingExpression*: 表达式 计算成布尔值决定该任务是否被阻塞

If a task is non-blocking, the engine will simply complete it automatically when executing it. If a task is blocking, a _PlanItemInstance_ for this task will remain in the _active_ state until it is programmatically triggered by the _CmmnRuntimeService.triggerPlanItemInstance(String planItemInstanceId)_ method.

如果一个任务是 非阻塞non-blocking, 引擎将在执行时自动完成它. 如果一个任务被阻塞blocking, 这个任务对应的计划项实例会被保持激活状态active state,
直到以编程方式触发( _CmmnRuntimeService.triggerPlanItemInstance(String planItemInstanceId)_ 方法).

A task is visualized as a rounded rectangle:

一个任务看作一个圆角矩形:

image::images/cmmn.task.png[align="center"]

==== Human task

==== 人工任务

A human task is used to model work that needs to be done by a human, typically through a form. When the engine arrives at a human task, a new entry is created in the task list of any users or groups assigned to that task.

一个人工任务用作模型化需要人完成的工作, 比如表单. 当引擎抵达一个人工任务, 被指派的人工或组对应的任务列表就会新增加一项.

A human task is a plan item, which means that beyond a human task entry also a _PlanItemInstance_ is created and it can be queried via the _PlanItemInstanceQuery_.

一个人工任务也是一个计划项, 这意味着除了人工任务本身之外，还创建了一个 _PlanItemInstance_,并且可以通过 _PlanItemInstanceQuery_ 查询它.

Human tasks can be queried through the _org.flowable.task.api.TaskQuery_ API. Historic task data can be queried through the _org.flowable.task.api.history.HistoricTaskInstanceQuery_.

人工任务可以通过 _org.flowable.task.api.TaskQuery_ API 查询.历史数据可以通过 _org.flowable.task.api.history.HistoricTaskInstanceQuery_ 查询.

Properties:

属性:

* *name*: expression that will be resolved at runtime as the name of the human task
* *name*: 被用作该人工任务的名称

* *blocking*: a boolean value determining whether the task blocks
* *blocking*: 布尔值决定该任务是否被阻塞

* *blockingExpression*: an expression that evaluates to a boolean indicating whether the tasks blocks
* *blockingExpression*: 表达式计算得到布尔值决定任务是否被阻塞

* *assignee* : an expression (can be a static text value) that is used to determine to whom the human task is assigned
* *assignee* : 表达式(可以是静态文本) 决定该任务的指派人

* *owner* : an expression (can be a static text value) that is used to determine who is the owner of the human task
* *owner* : 表达式(可以是静态文本)决定该任务的拥有者

* *candidateUsers* : an expression (can be a static text value) that resolves to a comma-separated list of Strings that is used to determine which users are candidate for this human task
* *candidateUsers* : 表达式(可以是静态文本)解析成以逗号分隔的字符串,被用作决定该人工任务的候选人列表

* *candidateGroups* : an expression (can be a static text value) that resolves to a comma-separated list of Strings that is used to determine to which groups the task is assigned
* *candidateGroups* : 表达式(可以是静态文本)解析成以逗号分隔的字符串,被用作决定该人工任务的候选组列表

* *form key*: an expression that determines a key when using forms. Can be retrieved via the API afterwards
* *form key*: 表达式决定使用表单的key, 后续通过API访问

* *Due date* an expression that resolves to java.util.Date or a ISO-8601 date string
* *Due date* 过期时间 解析为 java.util.Date or a ISO-8601 date string

* *Priority*: an expression that resolves to an integer. Can be used in the TaskQuery API to filter tasks
* *Priority*: 优先级 解析为整型, 可以用来在 TaskQuery API中筛选任务

A human task is visualized as a rounded rectangle with a user icon in the top left corner:

一个人工任务看作一个圆角矩形, 左上角有一个用户图标

image::images/cmmn.humantask.png[align="center"]

==== Java Service task

==== Java 服务任务

A service task is used to execute custom logic.

服务任务被用作执行自定义逻辑.

Custom logic is placed in a class that implements the _org.flowable.cmmn.api.delegate.PlanItemJavaDelegate_ interface.

自定义逻辑要放在一个实现 _org.flowable.cmmn.api.delegate.PlanItemJavaDelegate_ 接口的类中.

[source,java,linenums]
----
public class MyJavaDelegate implements PlanItemJavaDelegate {
    
    public void execute(DelegatePlanItemInstance planItemInstance) {
        String value = (String) planItemInstance.getVariable("someVariable");
        ...
    }

}
----

For lower-level implementations that cannot be covered by using the _PlanItemJavaDelegate_ approach, the _CmmnActivityBehavior_ can be used (similar to _JavaDelegate_ vs _ActivityBehavior_ in the BPMN engine). 

对于一些高级实现,使用 _PlanItemJavaDelegate_ 可能不能覆盖到, _CmmnActivityBehavior_可以被使用(类似于 BPMN 引擎中的 _JavaDelegate_ vs _ActivityBehavior_)


Properties:

属性:

* *name*: name of the service task
* *name*: 服务任务service task的名称

* *class*: the Java class implementing the custom logic
* *class*: 自定义逻辑的Java实现类

* *class fields*: parameters to pass when calling the custom logic
* *class fields*: 调用自定义逻辑时的传递参数

* *Delegate expression*: an expression that resolves to a class implementing the _PlanItemJavaDelegate_ interface
* *Delegate expression*: 表达式解析为一个实现_PlanItemJavaDelegate_接口的类

A service task is visualized as a rounded rectangle with a cog icon in the top left corner:

一个 服务任务service task 看作一个圆角矩形, 左上角有个齿轮图标

image::images/cmmn.servicetask.png[align="center"]

==== Decision task

==== Decision task 决策任务

A _Decision task_ calls out to a DMN decision table and stores the resulting variable in the case instance.

一个决策任务调用外部 DMN 决策表，并在case实例中存储结果变量

Properties:

属性:

* *Decision table reference*: the referenced DMN decision table that needs to be invoked.
* *Decision table reference*: 相关的需要被执行 DMN 决策表.

It is also possible to throw an error when no rule is hit during the evaluation of the DMN decision table by setting the '_Throw error if no rules were hit_' property. 

通过设置'_Throw error if no rules were hit_'属性, 当在 DMN 决策表计算过程中没有命中任何规则时, 可能会抛出错误.

A decision task is visualized as a _task_ with a table icon in the top left corner:

一个 服务任务service task 看作一个圆角矩形, 左上角有个表格图标

image::images/cmmn.decisiontask.png[align="center"]

==== Http Task

==== Http Task http请求任务

The Http task is an out-of-the-box implementation of a _service task_. It is used when a REST service needs to be called over HTTP.

Http Task http请求任务是 _service task_ 一个开箱即用的实现,被用作调用一个http REST 服务.

The Http task has various options to customize the request and response. See the BPMN http task documentation for details on all the configuration options.

Http Task http请求任务包含多个参数来自定义请求和响应. 查阅  BPMN http task documentation 了解更多参数设置的细节

A http task is visualized as a _task_ with a rocket icon in the top left corner:

一个 服务任务service task 看作一个圆角矩形, 左上角有个火箭图标

image::images/cmmn.httptask.png[align="center"]

==== Script Task

==== Script Task 脚本任务

A task of type "script", similar to its equivalent in BPMN, the Script Task executes a script when the plan item instance becomes active.

脚本任务类似 BPMN 中脚本任务, 当一个计划项变成激活状态, 用来执行一个脚本.

Properties:

属性:

* *name*: task attribute to indicate the name of the task
* *name*: 表示任务名称

* *type*: task attribute whose value must be "script" to indicate the type of task
* *type*: 任务属性, 必须是"script", 表示该任务类型

* *scriptFormat*: extended attribute that indicate the language of the script (for example, javascript, groovy)
* *scriptFormat*: 拓展属性 表示脚本语言(例如, javascript, groovy)

* *script*: the script to execute, defined as a string in a field element named "script"
* *script*: 执行的脚本, 在"script"元素中作为一个string

* *autoStoreVariables*: optional task attribute flag (default: false) that indicates whether or not variables defined in the script will be stored in the Plan Item Instance context (see note below)
* *autoStoreVariables*: 可选的任务属性标记 (默认: false) 表示脚本中定义的变量是否保存到计划项实例上下文中 (查看下面注意事项note)

* *resultVariableName*: optional task attribute that when present will store a variable with the specified name in the Plan Item instance context with the script evaluation result (see note below)
* *resultVariableName*: 可选的任务属性 明确脚本执行结果保存到计划项实例上下文中对应的名称 (查看下面注意事项note)

A script task is visualized as a _task_ with a script icon in the top left corner:

一个 服务任务service task 看作一个圆角矩形, 左上角有个脚本图标

image::images/cmmn.scripttask.png[align="center"]

[source,xml,linenums]
----
<planItem id="scriptPlanItem" name="Script Plan Item" definitionRef="myScriptTask" />
<task name="My Script Task Item" flowable:type="script" flowable:scriptFormat="JavaScript">
    <documentation>Optional documentation</documentation>
    <extensionElements>
        <flowable:field name="script">
            <string>
                sum = 0;
                for ( i in inputArray ) {
                    sum += i;
                }
            </string>
        </flowable:field>
    </extensionElements>
</task>
----

*Note*: The value of the *scriptFormat* attribute must be a name that is compatible with the link:$$http://jcp.org/en/jsr/detail?id=223$$[JSR-223] (scripting for the Java platform). By default, JavaScript is included in every JDK and as such doesn't need any additional JAR files. If you want to use another (JSR-223 compatible) scripting engine, it is sufficient to add the corresponding JAR to the classpath and use the appropriate name. For example, the Flowable unit tests often use Groovy because the syntax is similar to that of Java.

*Note*: *scriptFormat* 属性值必须符合 link:$$http://jcp.org/en/jsr/detail?id=223$$[JSR-223] (scripting for the Java platform).
默认, JavaScript 包含在每个JDK里, 不需要额外的JAR文件. 如果你想使用另外 (JSR-223 兼容) 脚本引擎, 在classpath中添加对应的Jar文件并使用合适的名称.
例如, Flowable 单元测试 经常使用 Groovy, 因为其语法和 JAVA 相像.

Do note that the Groovy scripting engine is bundled with the groovy-jsr223 JAR. As such, one must add the following dependency:

注意Groovy脚本引擎是绑定在groovy-jsr223 JAR, 这样, 必须添加下面的依赖:

[source,xml,linenums]
----
<dependency>
    <groupId>org.codehaus.groovy</groupId>
    <artifactId>groovy-jsr223</artifactId>
    <version>2.x.x<version>
</dependency>
----

All case variables that are accessible through the PlanItem instance that arrives in the script task can be used within the script. In the example below, the script variable _'inputArray'_ is in fact a case variable (an array of integers).

在脚本任务中, 所有案例变量 variables 都可以通过 PlanItem 实例在脚本中访问.在下面的例子中, 脚本变量 _'inputArray'_ 实际上是一个案例变量variable(一个整型数组)

[source,xml,linenums]
----
<flowable:field name="script">
    <string>
    sum = 0
    for ( i in inputArray ) {
      sum += i
    }
    </string>
</flowable:field>
----

*Note*: It's also possible to set plan item instance variables in a script, simply by calling _planItemInstance.setVariable("variableName", variableValue)_. By default, no variables are stored automatically. It's possible to automatically store any variable defined in the script (for example, __sum__ in the example above) by setting the property ++autoStoreVariables++ on the ++scriptTask++ to ++true++. However, *the best practice is not to do this and use an explicit planItemInstance.setVariable() call*, as with some recent versions of the JDK, auto storing of variables does not work for some scripting languages. See link:$$http://www.jorambarrez.be/blog/2013/03/25/bug-on-jdk-1-7-0_17-when-using-scripttask-in-activiti/$$[this link] for more details.

*Note*: 通过在脚本中调用 _planItemInstance.setVariable("variableName", variableValue)_, 可以设置计划项实例的变量值.默认不会保存任务变量.
通过设置 _autoStoreVariables_属性值为true, 也可以自动保存在脚本中定义的变量(例如, 上述实例中的sum).然而, 最好是不要显示调用 _planItemInstance.setVariable("variableName", variableValue)_
,在某些版本的JDK中, 一些脚本语言自动保存变量会不起作用. 查阅 link:$$http://www.jorambarrez.be/blog/2013/03/25/bug-on-jdk-1-7-0_17-when-using-scripttask-in-activiti/$$[链接] 了解更多细节


[source,xml,linenums]
----
<task name="Script Task" flowable:type="script" flowable:scriptFormat="groovy" flowable:autoStoreVariables="false">
----

The default for this parameter is +false+, meaning that if the parameter is omitted from the script task definition, all the declared variables will only exist during the duration of the script.

该参数默认是false, 意味着在脚本定义中省略, 所有脚本中声明的变量只会存在于脚本执行过程中.

Here's an example of how to set a variable in a script:

这是一个在脚本中如何设置变量的例子:

[source,xml,linenums]
----
<flowable:field name="script">
    <string>
    def scriptVar = "test123"
    planItemInstance.setVariable("myVar", scriptVar)
    </string>
</flowable:field>
----

The following names are reserved and *cannot be used* as variable names: *out, out:print, lang:import, context, elcontext*.

以下名称是预留的, *cannot be used* 不能被使用: *out, out:print, lang:import, context, elcontext*.

*Note* The return value of a script task can be assigned to an already existing or new plan item instance variable by specifying its name as a literal value for the _'flowable:resultVariable'_ attribute of a script task definition. Any existing value for a specific plan item instance variable will be overwritten by the result value of the script execution. When a result variable name is not specified, the script result value gets ignored.

[source,xml,linenums]
----
<task name="Script Task" flowable:type="script" flowable:scriptFormat="groovy" flowable:resultVariable="myVar">
    <flowable:field name="script">
        <string>#{echo}</string>
    </flowable:field>
</task>
----

In the above example, the result of the script execution (the value of the resolved expression __'#{echo}'__) is set to the process variable named __'myVar'__ after the script completes.

==== Milestone

A milestone is used to mark arriving at a certain point in the case instance. At runtime, they are represented as *MilestoneInstances* and they can be queried through the *MilestoneInstanceQuery* via the _CmmnRuntimeService_. There is also a historical counterpart via the _CmmnHistoryService_.

A milestone is a plan item, which means that as well as a milestone entry, a _PlanItemInstance_ is created also, which can be queried via the _PlanItemInstanceQuery_.


Properties:

* *name*: an expression or static text that determines the name of the milestone

A milestone is visualized as a rounded rectangle (more rounded than a task):

image::images/cmmn.milestone.png[align="center"]

==== Case task

A case task is used to start a child case within the context of another case. The _CaseInstanceQuery_ has _parent_ options to find these cases.

When the case task is blocking, the _PlanItemInstance_ will be _active_ until the child case has completely finished. If the case task is non-blocking, the child case is started and the plan item instance automatically completes. When the child case instance ends there is no impact on the parent case.

Properties:

* *name*: an expression or static text that determines the name
* *blocking*: a boolean value determining whether the task blocks
* *blockingExpression*: an expression that evaluates to a boolean indicating whether the tasks blocks
* *Case reference*: the key of the case definition that is used to start the child case instance. Can be an expression

A case task is visualized as a rounded rectangle with a case icon in the top left corner:

image::images/cmmn.casetask.png[align="center"]

==== Process task

A process task is used to start a process instance within the context of a case.

When the process task is blocking, the _PlanItemInstance_ will be _active_ until the process instance has completely finished. If the process task is non-blocking, the process instance is started and the plan item instance automatically completes. When the process instance ends there is no impact on the parent case.

Properties:

* *name*: an expression or static text that determines the name
* *blocking*: a boolean value determining whether the task blocks
* *blockingExpression*: an expression that evaluates to a boolean indicating whether the tasks blocks
* *Process reference*: the key of the process definition that is used to start the process instance. Can be an expression

A process task is visualized as a rounded rectangle with an arrow icon in the top left corner:

image::images/cmmn.processtask.png[align="center"]

A process task can be configured to have in- and out parameters, which take the form of _source/sourceExpression_ and _target/targetExpression_.

The in parameters are resolved within context of the case instance.

* The _source_ value will be the case instance variable which value will be mapped to a process variable
* Alternatively, the _sourceExpression_ allows to create an arbitrary value, where the expression is resolved against the case instance.
* The _target_ will be the name of the process variable to which the source value is mapped.
* Alternatively, the _targetExpression_ will resolve to a *string* value that is used as variable name in the process instance. The expression is resolved within case instance context.

The out parameters are resolved within context of the process instance.

* The _source_ value will be the process instance variable which value will be mapped to a case variable
* Alternatively, the _sourceExpression_ allows to create an arbitrary value, where the expression is resolved against the process instance.
* The _target_ will be the name of the case variable to which the source value is mapped.
* Alternatively, the _targetExpression_ will resolve to a *string* value that is used as variable name in the case instance. The expression is resolved within process instance context.

==== Criteria

===== Entry criterion (entry sentry)

Entry criteria form a sentry for a given plan item instance. They consist of two parts:

* One or more parts that depend on other plan items: these define dependencies on state transitions of other plan items. For example, one human task can depend on the state transition 'complete' of three other human tasks to become active itself
* One optional _if part_ or _condition_: this is an expression that allows the definition of a complex condition

A sentry is satisfied when all its criteria are resolved to _true_. When a criterion evaluates to true, this is stored and remembered for future evaluations. Note that entry criteria of all plan item instances in the _available_ state are evaluated whenever something changes in the case instance.
Multiple sentries are possible on a plan item. However, when one is satisfied, the plan item moves from state _available_ to _active_.

See <<cmmn_sentry_evaluation,the section on sentry evaluation>> for more information.

An entry criterion is visualized as a diamond shape (white color inside) on the border of a plan item:

image::images/cmmn.entrycriteria.png[align="center"]

===== Exit criterion (exit sentry)

Exit criteria form a sentry for a given plan item instance. They consist of two parts:

* One or more parts that depend on other plan items: these define dependencies on state transitions of other plan items. For example, one human task can depend on reaching a certain milestone to be automatically terminated
* One optional _if part_ or _condition_: this is an expression that allows a complex condition to be defined

A sentry is satisfied when all its criteria are resolved to _true_. When a criterion evaluates to true, this is stored and remembered for future evaluations. Note that exit criteria of all plan item instances in the _active_ state are evaluated whenever something changes in the case instance.
Multiple sentries are possible on a plan item. However, when one is satisfied, the plan item moves from state _active_ to _exit_.

See <<cmmn_sentry_evaluation,the section on sentry evaluation>> for more information.

An exit criterion is visualized as a diamond shape (white color inside) on the border of a plan item:

image::images/cmmn.exitcriteria.png[align="center"]

==== Event Listeners

===== Timer Event Listener

A timer event listener is used when the passing of time needs to be captured in a case model.

A timer event listener is not a task and has a simpler plan item lifecycle compared to a _task_: the timer will simply move from _available_ to _completed_ when the event (in this case, the time passing) occurs.

Properties:

* *Timer expression*: an expression that defines when the timer should occur. The following options are possible:
** An expression resolving to a java.util.Date or org.joda.time.DateTime instance (for example, _${someBean.calculateNextDate(someCaseInstanceVariable)})
** An ISO8601 date 
** An ISO8601 duration String (for example, _PT5H_, indicating the timer should fire in 5 hours from instantiation)
** AN ISO8601 repetition String (for example, R5/PT2H, indicating the timer should fire 5 times, each time waiting 2 hours)  
** A String containing a cron expression
* *Start trigger plan item/event*: reference to a plan item in the case model that triggers the start of the timer event listener

Note that setting a _start trigger_ for the timer event listener does not have a visual indicator in the case model, unlike entry/exit criteria on sentries.

A timer event listener is visualized as circle with a clock icon inside:

image::images/cmmn.timereventlistener.png[align="center"]

===== User Event Listener

A user event listener can be used when needing to capture a user interaction that directly influences a case state,
instead of indirectly via impacting variables or information in the case.
A typical use case for a user event listener are buttons in a UI that a user can click to drive the state of the case instance.
When the event is triggered an _Occur_ event is thrown to which sentries can listener to.
Like timer event listeners, it has a much simpler lifecycle that a _task_.

image::images/cmmn.usereventlistener.png[align="center"]

User event listeners can be queried using the _org.flowable.cmmn.api.runtime.UserEventListenerInstanceQuery_. Such a query can be created by calling the _cmmnRuntimeService.createUserEventListenerInstanceQuery()_ method. Note that a user event listener is also a plan item instance, which means it can also be queried through the _org.flowable.cmmn.api.runtime.PlanItemInstanceQuery_ API.

A user event listener can be completed by calling the _cmmnRuntimeService.completeUserEventListenerInstance(id)_ method.

===== Generic Event Listener

A generic event listener is used to typically model a programmatic interaction (e.g. a external system that calls out to change something in a case instance).

image::images/cmmn.generic-event-listener.png[align="center"]

The API to retrieve and complete these event listeners is on the _CmmnRuntimeService_:

[source,java,linenums]
----
GenericEventListenerInstanceQuery createGenericEventListenerInstanceQuery();
void completeGenericEventListenerInstance(String genericEventListenerInstanceId);
----

Similar to _user event listeners_, this API is a wrapper on top of the _PlanItemInstance_ queries and operations. This means that the data can also be retrieved through the regular _PlanItemInstanceQuery_

Note that generic event listeners are not part of the CMMN specification, but are a Flowable-specific addition.


===== Automatic removal of event listeners

The engine will automatically detect when event listeners (user or timer) are not useful anymore.
Take for example the following case definition:

image::images/cmmn.user-event-listener-removal-1.png[align="center"]

Here, the _First stage_ contains two human tasks (A and B) and it can be exited by a user when the _Stop first stage_ user event is triggered.
However, when both taks A and B are completed, the stage will also complete. If now the user event listener would be triggered, there is nothing that listens to this event anymore.
The engine will detect this and terminate the user event automatically.

The same mechanism also works for event listeners that are referenced by entry sentries:

image::images/cmmn.user-event-listener-removal-2.png[align="center"]

In this case, in the case that _EventListenerA_ would be triggered, _EventListenerB_ is terminated (as nothing is listening to its occurrence anymore).

Or, when timer and user event listeners are mixed, the one that is triggered first will also cause the removal of others (when they are not referenced somewhere else):

image::images/cmmn.user-event-listener-removal-3.png[align="center"]

Here, the timer will be removed in case the user event is triggered first (and vice versa).

The detection also takes in account plan items that have not yet been created. Take for example the following case definition:

image::images/cmmn.user-event-listener-removal-4.png[align="center"]

Here, human task _C_ is not yet created when a case instance is started for this case definition. The user event listener will not be removed as long that _C_ has a parent stage that is in a non-terminal state, as this means that the event could still be listened to in the future.

===== Available condition

All types of event listeners can be configured to have a *available condition*: an expressions that will guard the available state of the event listener. To explain the use case, take the following case definition:

image::images/cmmn.create-condition.png[align="center"]

When the case instance is started, Stage 1 (as it has no entry criteria) will be moving immediately from _available_ to _active_. Similar story for human task A. Human task B will move from _available_ to _enabled_ as it's manually activated.

Normally, also the event listener would become _available_. The life cycle of event listeners is simpler than that of plan items such as human tasks: an event listener stays in the _available_ state until the event happens. There's no _active_ state like for other plan items.
This means that a user could trigger it after start and the stage would be exited.

In some use case however, the event listener shouldn't be _available_ for the user to interact with (or a timer shouldn't start, when using a timer event listener) unless a certain condition is true.

In the example above, we want to only create it when the stage doesn't have any active children (or required) anymore. Setting the *availableCondition* to *${cmmn:isStageCompletable()}* will allow the event listener to be created which makes it move immediately to _available_. Concretely in this model, when human task A is completed Stage 1 becomes _completable_ (as human task B is manually activated and non-required). This makes the _availbleCondition_ of the event listener _true_ and the event listener is now available for a user to decide to exit the stage.

Note: this is a Flowable specific addition to the CMMN specification. Without this addition, the event listener would have to be nested within a substage which is protected with entry criteria that listens to the completion of task A.

Note: if this were an autocompletable stage, the engine would complete the stage automatically when A completes.

==== Item control: Repetition Rule

Plan items on the case model can have a _repetition rule_: an expression that can be used to indicate a certain plan item needs to be repeated.
When no expression is set, but the repetition is enabled (for example, the checkbox is checked in the Flowable Modeler) or the expression is empty, a _true_ value is assumed by default.

An optional _repetition counter variable_ can be set, which holds the index (one-based) of the instance. If not set, the default variable name is _repeitionCounter_.

If the plan item does not have any entry criteria, the repetition rule expression is evaluated when the plan item is completed or terminated. If the expression resolved to _true_, a new instance is created. For example, a human task with a repetition rule expression _${repetitionCounter < 3}_, will create three sequential human tasks.

If the plan item has entry criteria, the behavior is different. The repetition rule is not evaluated on completion or termination, but when a sentry of the plan item is satisfied. If both the sentry is satisfied and the repetition rule evaluates to true, a new instance is created. 

Take, for example, the following timer event listener followed by a human task. The sentry has one entry criterion for the _occur_ event of the timer event listener. Note that enabling and setting the repetition rule on the task has a visual indicator at the bottom of the rectangle.  

image::images/cmmn.repeatingtimereventlistener.png[align="center"]

If the timer event listener is repeating (for example, _R/PT1H_), the _occur_ event will be fired every hour. When the repetition rule expression of the human task evaluates to true, a new human task instance will be created each hour.

Note that Flowable allows to have repeating user and generic event listeners. This is contrary to the CMMN specification (which disallows it), but we believe it is needed for having a more flexible way of using event listeners (for example to model a case where a user might multiple times trigger an action that leads to the creation of tasks).

==== Item control: Manual Activation Rule

Plan items on the case model can have a _manual activation rule_: an expression that can be used to indicate a certain plan item needs to be _manually activated by an end-user_.
When no expression is set, but the manual activation is enabled (for example, the checkbox is checked in the Flowable Modeler) or the expression is empty, a _true_ value is assumed by default.

Stages and all task types can be marked for manual activation. Visually, the task or stage will get a 'play' icon (small triangle pointing to the right) to indicate an end-user will have to manually activate it: 

image::images/cmmn.manual-activation.png[align="center"]

Normally, when a sentry for a plan item is satisfied (or the plan item doesn't have any sentries) the plan item instance is automatically moved to the _ACTIVE_ state. When a manual activation is set though, and it evaluates to true, the plan item instance now becomes _ENABLED_ instead of _ACTIVE_. As the name implies, the idea behind this is that end-users manually have to activate the plan item instance. A typical use case is showing a list of buttons of potential plan item instances that can currently be started by the end user.

To start an enabled plan item instance, the _startPlanItemInstance_ method of the _CmmnRuntimeService_ can be used:

[source,java,linenums]
----
List<PlanItemInstance> enabledPlanItemInstances = cmmnRuntimeService.createPlanItemInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .planItemInstanceStateEnabled()
    .list();
    
// ...
        
cmmnRuntimeService.startPlanItemInstance(planItemInstance.getId());
----

Note that the behavior of a task is only executed when the plan item instance moves into the _ACTIVE_ state. For example, for a human task, the user task will only be created after calling the _startPlanItemInstance_ method.

Plan item instances that are enabled can be moved into the _DISABLED_ state:

[source,java,linenums]
----
cmmnRuntimeService.disablePlanItemInstance(planItemInstance.getId());
----

Disabled plan item instances can be enabled again:
[source,java,linenums]
----
cmmnRuntimeService.enablePlanItemInstance(planItemInstance.getId());
----

Note that with regards to determining stage or case instance termination, the _DISABLED_ state is seen as a 'terminal' state. This means that the case instance will terminate when only disabled plan item instances would remain.

==== Item control: Required Rule

Plan items on the case model can have a _required rule_: an expression that can be used to indicate a certain plan item is _required by the enclosing stage (or plan model)_. This can be used to indicate which plan items of the case model are required to be executed and which are optional.

When no expression is set, but the required rule is enabled (for example, the checkbox is checked in the Flowable Modeler) or the expression is empty, a _true_ value is assumed by default.

The _required rule_ works in conjunction with the _autoComplete_ attribute on the parent stage:

* If _autoComplete_ resolves to _false_ for the stage, which is also the default when nothing is set, *all* child plan item instances must be in an end state (completed, terminated, and so on) for the stage plan item instance to be completed by the engine
* If _autoComplete_ resolves to _true_ for the stage, all child plan item instances for *which the required rule evaluates to true* need to be in an end state. If there are also no other active child plan item instances, the stage completes automatically

A _stage plan item instance_ has a *completeable* property that can be used to see whether or not the conditions for completion are satisfied.
Take, for example, the following simple stage and assume that the sentry for the _required task_ evaluates to true and the other one to false. This means that the left plan item instance will be active while the right one will be in the _available_ state.

image::images/cmmn.completeable-stage.png[align="center"]

Calling _cmmnRuntimeService.completeStagePlanItemInstance(String stagePlanItemInstanceId)_ will not be possible for the stage (an exception will be thrown) as it has one active child plan item instance. When this user task on the left is completed, the _completeStagePlanItemInstance_ can now be called, as no child plan item instances are currently active. However, by itself, the stage will not automatically complete as the right user task is in the available state.

If the previous stage is changed to be *autoCompleteable* (this is visualised by a black rectangle at the bottom of the stage) and the plan item on the left is changed to be required (this is visualised using an exclamation mark), the behavior will be different:

image::images/cmmn.completeable-stage02.png[align="center"]

* If the left plan item instance is active (sentry is true) and the right is not (sentry is false). In this case, when the left user task is completed, the stage instance will auto complete as it has no active child plan item instances and all required plan item instances are in an end state 
* If both the left and right user tasks are active (sentries are true)
** When the left user task is completed, the stage will not autocomplete as there is still a child plan item instance active
** When the right user task is completed, the stage will not autocomplete as the required left child plan item instance is not in an end state
* If the left plan item instance is not active and the right is active. In this case, when the right user task is completed the stage will not autocomplete, as the required left user task is not in an end state. It will need to become active and be completed to complete the stage.

Note that the manual activation rule works independently of the required rule. For example, given the following stage: 

image::images/cmmn.completeable-stage03.png[align="center"]

Here, user task D is required and user task B is manually activated. 

* If D is completed, the stage will automatically complete, as B is not required and it is not active
* If B would be required too, it would need to be manually started (using _cmmnRuntimeService.startPlanItemInstance(String planItemInstanceId)_) before the stage would automatically complete, even if D would be completed before the manual start of B

==== Item control: Completion Neutral Rule

Plan items on the case model can have a _completion neutral rule_: an expression that can be used to indicate a certain plan item is _neutral with regards to the completion of its parent stage (or plan model)_. This can be used to indicate which plan items of the case model are required to be executed and which are optional, as a more flexible alternative in some use cases to using the _required rule_ and _autoComplete_ .

Note that the _Completion Neutral Rule_ is not a CMMN 1.1 Standard, but a Flowable-specific addition.

Following the specification, a stage with a plan item in state *AVAILABLE* does not complete unless its _autoComplete_ attribute is set _true_ and the plan item is not required. For example, a plan item that has an unsatisfied sentry remains in *AVAILABLE* until the sentry is satisfied. This means that the parent stage would not complete, unless the plan item is marked as _not required_ and the stage is set to _autoComplete_. The downside is that once a stage is marked as to autoComplete, all child plan items need to have a configuration for the _required_ rule, which is in some use cases tedious and lots of work.

The _Completion Neutral Rule_, contrary to the autoComplete-required mechanism, works from "bottom-up": a plan item can be marked individually to be _neutral wrt the completion of its parent_ without having to mark any other plan item.

The _Required Rule_ takes precedence when plan items with both rules both evaluate to _true_.

To summarize:

* a plan item configured to be _"completion neutral"_ will allow a stage to complete automatically if it's in *AVAILABLE* state (e.g. waiting for an entry criterion sentry),meaning that such a plan item is neutral with respect to its parent stage completion evaluation.

* a stage will remain *ACTIVE* on any of these conditions:
    1. It has at least one plan item in *ACTIVE* state
    2. It has at least one plan item with _requiredRule_ in *AVAILABLE* or *ENABLE* state
    3. It is not marked as _autoComplete_ and has at least one plan item in *ENABLED* state (irrespective of its _requiredRule_)
    4. It is not marked as  _autoComplete_ and has at least one plan item in *AVAILABLE* state that is *not* _completionNeutral_

* a stage will *COMPLETE* if:
    1. It contains no plan items or all child plan items are in a _Terminal_ or _Semi-terminal_ state (CLOSED, COMPLETED, DISABLED, FAILED)
    2. It is not marked as _autoComplete_ and all remaining child plan items are in *AVAILABLE* state and are _completionNeutral_ and not _required_
    3. It is _autoComplete_ and all remaining plan items are _not required_ in *ENABLED* or *AVAILABLE* state (regardless of its completion neutrality, as required rule gets precedence)

[[cmmn_sentry_evaluation]]
=== Sentry evaluation

Sentries play a big role in any case definition as they offer a powerful way of configuring in a declarative way when certain plan item instances activate or when they are automatically stopped.
As such, one of the most important parts of the Flowable CMMN engine core logic is to evaluate the sentries to see what state changes happen in a case instance.

==== When are sentries evaluated?

Sentries are evaluated whenever state changes happen in the case instance or new events happen. Concretely this means:

* When a case instance is started.
* When a wait state plan item such as a human task is triggered to continue.
* When variables related to the case instance change (added, updated or deleted).
* When the state of a plan item instance is changed (e.g. terminated through RuntimeService, a manual plan item instance is started, etc.).
* When manually triggered through the RuntimeService#evaluateCriteria method.

The engine will continue to plan new evaluations of all currently active sentries as long as changes keep happening.
For example, suppose the completion of a human task satisfies the exit sentry of another human task. The state change of the second human task will again schedule a new evaluation of all active sentries with this new information. When no changes have happened during the last evaluation, the engine deems the state stable and evaluation is stopped.

==== Concepts

Sentries consist of two parts:

- One or more _onParts_ that reference lifecycle events from other plan items
- Zero or one ifPart with a condition

Take for example the following case definition:

image::images/cmmn.sentry-eval-01.png[align="center"]

Assume (not shown in the diagram here)

* The entry sentry on task C listens to the _complete_ event from task A and B.
* The exit sentry listens to the _occur_ event of the user event listener _'Stop  C'_
* The entry sentry has a condition expression set to _${var:eq(myVar, 'hello world')}_

In this simple example, the _entry sentry_ has two onParts and one ifPart. The _exit sentry_ only has onPart.

When the case instance is started, human tasks A and B are created (as they have no entry sentry) and move immediately to state _active_. C is not _active_, but _available_ as the sentry has not yet been satisfied. The user event listener _'Stop C'_ is also _available_ from the start and it can thus be triggered.

When both task A and B have been completed and the variable _myVar_ is set to _'hello world'_, the entry sentry is satisfied and fires. The plan item instance behind C is moved to the _active_ state and as a side-effect the human task C is created (it can now be queried through the _TaskService_ for example).
When _'Stop C'_ is triggered (through the _CmmnRuntimeService#completeUserEventListenerInstance_ method, the exit sentry for C is satisfied and C is terminated.

If _'Stop C'_ would be triggered before C moves to _active_, its plan item instance would be terminated and the entry sentry won't be listening anymore to anything.

==== Default behavior

When the case instance is started

----
CaseInstance caseInstance = cmmnRuntimeService.createCaseInstanceBuilder()
    .caseDefinitionKey("myCase")
    .start();
----

the condition on the entry sentry is immediately evaluated, as a regular evaluation cycle happens on case instance start.

Note that, if an expression for the condition like _${myVar == 'hello world'}_ would be used this would not work. The engine would throw a _PropertyNotFound_ exception as it doesn't know the _myVar_ variable.

To solve this:

 * pass a variable value for _myVar_ on case instance start
 * do a null check in the expression, like _${planItemInstance.getVariable('myVar') != null && planItemInstance.getVariable('myVar') == 'hello world'}_
 * or (and probably easiest), check <<cmmnExpressionsFunctions,expression functions>> to use a function such as _${var:eq(myVar, 'hello world')}_ which takes in account the fact the variable might not exist.

*The default evaluation logic has "memory", which means that when a part of a sentry is satisfied the engine will store and "remember" this in subsequent evaluations.*

This means that, from the moment a part (an onPart or ifPart of the sentry) is satisfied, that particular part is not evaluated anymore in next evaluations and it is deemed true.

In the example above, this is needed as task A will typically be completed at another point in time than task B. For example if task A is completed, the part of the sentry on task C that says "i'm listening to the complete event of task A" is now satisfied and this fact is remembered for the future. If now B completes, this is also stored. If now the _myVar_ variable gets the right value, the ifPart also fires and the whole sentry fires and task C gets activated. Of course, it could also be that the variable value is satisfied first and the tasks after. The point is that it doesn't matter as the engine will remember the parts that were satisfied in the past.

This behavior "with memory" is the default behavior of the engine and is covered by setting the _triggerMode_ of a sentry to *default*. This is automatically set in the Flowable Modeler when adding a new plan item. When no value has been set (for example when importing a case model from another tool), the _triggerMode_ is assumed to be _default_.

==== Trigger mode "onEvent"

The default behavior (see previous section) will remember which parts have been satisfied previously. This is the most used and safest approach (and also what is typically expected when reasoning about sentries).

There is an alternative mode of sentry triggering that is called *"onEvent"*. In this mode, the engine will have memory with regards to parts of the sentry and will *not remember* any part that was satisfied in the past. This is sometimes needed in advanced use cases. Take for example the following example:

image::images/cmmn.sentry-eval-02.png[align="center"]

Here, the case model has a stage with with three substages. All substage are repeating. Substage B and C have an entry sentry for the completion of stage B. Also (not visually shown), both sentries have a condition that depends on a variable.

In advanced use cases, it could be wanted or needed that that the sentry parts (and especially the ifPart containing the condition) are evaluated only _when the lifecycle event of the dependent plan item_ happens. In this case, this is the _complete_ event of _Stage A_. For these use cases, the _triggerMode_ of the sentry can be set to _onEvent_. As the name imples, this means that the sentry evaluation only happens when a referenced event happens and no memory of past things are taken into account.

Concretely, in the example here, the condition of the entry sentries will be evaluated *only* when Stage A completed (and on no other moment). This is very different from the general evaluation rules. In this particular example, it does make managing the variables easier as the conditions are only evaluated on one precise moment and there needs to be no fear of some sentry part being fired due to a variable having a value at a certain point in time. Especially as in the example here all substages are repeating, this would be a lot of work to do. This is a powerful mechanism, but meant for advanced modelers that have an intrinsic knowledge of the case model and the semantics of this triggerMode.

Do note that the engine deems all events to happen simultaneously when it comes to evaluating sentries. Take the following case definition:

image::images/cmmn.sentry-eval-03.png[align="center"]

Assume that all sentries use the _triggerMode onEvent_ setting. If task A is completed, this exits task B. Task C will now exit too. So, even though there are two distinct lifecycle events (A being completed and B being exited) and one might assume that _onEvent_ literally means that there are two distinct evaluations happening where the memory of the other part of the exit sentry on task C is forgotten, the engine is smart enough to see that they are part of the same evaluation cycle and task C will be exited too.

Technically spoken: there is _some_ memory for the _onEvent_ sentry, more specifically for evaluations that happen during the same API call (or transaction, lower-level spoken).

*Important: onEvent is a powerful mechanism and should only be used when the semantics are well understood. It's possible to create a case model that gets stuck due to not having the correct sentry configuration if the use case is not carefully examined.*

(For example, suppose a sentry has an onPart listening to the completion of a plan item and an ifPart with a condition. If the plan item completes - thus triggering the onPart - but a variable used in the condition is missing for some reason ... the ifPart would never fire and the case instance might get stuck in an unwanted state).
